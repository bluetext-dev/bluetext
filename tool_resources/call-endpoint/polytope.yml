tools:
  call-endpoint:
    info: |
      Makes HTTP requests to services running in the sandbox network.
      Use this instead of curl to reach services â€” it runs inside the sandbox network via a container.

      Provide either `service` (resolves host/port from values context) or `url` (raw URL). Not both.

      Examples:
        call-endpoint(service: "python-fast-api", path: "/health")
        call-endpoint(service: "kong", path: "/api/users")
        call-endpoint(url: "http://python-fast-api:3030/docs")
        call-endpoint(service: "python-fast-api", path: "/users", method: "POST", body: '{"name": "Alice"}')
    inputs:
      service:
        info: "Service name (e.g., python-fast-api, kong). Resolves host/port from values context."
        type: [default, str, ""]
      url:
        info: "Raw URL to call. Use service hostnames (e.g., http://python-fast-api:3030/health) since requests run inside the sandbox network."
        type: [default, str, ""]
      path:
        info: "Path to append when using service mode (e.g., /health, /api/users)."
        type: [default, str, "/"]
      method:
        info: "HTTP method."
        type: [default, [enum, GET, POST, PUT, PATCH, DELETE], GET]
      body:
        info: "Request body as a JSON string."
        type: [default, str, ""]
      headers:
        info: "Additional headers as a JSON object string (e.g., '{\"Authorization\": \"Bearer token\"}')."
        type: [default, str, ""]
    run:
      - id: make-request
        code: |-
          pt.clj
          (let [service (let [s (:service inputs)] (when (and s (not= s "")) s))
                raw-url (let [u (:url inputs)] (when (and u (not= u "")) u))
                path    (or (:path inputs) "/")
                method  (clojure.string/upper-case (or (:method inputs) "GET"))
                body    (let [b (:body inputs)] (when (and b (not= b "")) b))
                hdrs    (let [h (:headers inputs)] (when (and h (not= h "")) h))

                ;; Validate: must provide service or url, not both
                _ (when (and (nil? service) (nil? raw-url))
                    (pt/fail "Must provide either 'service' or 'url'."))
                _ (when (and service raw-url)
                    (pt/fail "Provide either 'service' or 'url', not both."))

                ;; Parse and validate headers
                _ (when hdrs
                    (try
                      (let [parsed (pt/read-json hdrs)]
                        (when-not (map? parsed)
                          (pt/fail (str "Invalid 'headers' parameter: expected a JSON object, got " (type parsed) "."))))
                      (catch Exception _
                        (pt/fail (str "Invalid 'headers' parameter: could not parse as JSON. Expected a JSON object string like '{\"Authorization\": \"Bearer token\"}', got: " hdrs)))))

                ;; Helper: try to read a value, return nil if missing
                try-value (fn [k] (try (pt/value k) (catch Exception _ nil)))

                ;; Resolve URL â€” use service hostname for container network access
                url (if service
                      (let [port (or (try-value (str service "-http-port"))
                                     (try-value (str service "-proxy-port"))
                                     (try-value (str service "-port")))]
                        (when (nil? port)
                          (pt/fail (str "Could not resolve port for service '" service "'. Make sure the service is running and has registered its port in the values context.")))
                        (str "http://" service ":" port path))
                      raw-url)

                _ (pt/log (str method " " url))

                ;; Build Python script to make the request from inside the sandbox network
                ;; Escaping: use Clojure pr-str to safely embed strings into Python code
                py-url (pr-str url)
                py-method (pr-str method)
                py-body (if body (pr-str body) "None")
                py-hdrs (if hdrs hdrs "{}")

                py-script (str
                  "import urllib.request, json, sys\n"
                  "url = " py-url "\n"
                  "method = " py-method "\n"
                  "body_str = " py-body "\n"
                  "body = body_str.encode('utf-8') if body_str else None\n"
                  "headers = " py-hdrs "\n"
                  "if body and 'Content-Type' not in headers:\n"
                  "    headers['Content-Type'] = 'application/json'\n"
                  "req = urllib.request.Request(url, data=body, headers=headers, method=method)\n"
                  "try:\n"
                  "    resp = urllib.request.urlopen(req)\n"
                  "    result = {'status': resp.status, 'headers': dict(resp.headers), 'body': resp.read().decode('utf-8', errors='replace')}\n"
                  "except urllib.error.HTTPError as e:\n"
                  "    result = {'status': e.code, 'headers': dict(e.headers), 'body': e.read().decode('utf-8', errors='replace')}\n"
                  "except Exception as e:\n"
                  "    result = {'status': 0, 'headers': {}, 'body': str(e), 'error': str(e)}\n"
                  "with open('/repo/.polytope-call-endpoint-result.json', 'w') as f:\n"
                  "    json.dump(result, f)\n")

                ;; Execute request via pt/run-script (runs in sandbox network)
                _ (pt/call-module "pt/run-script" {:repo {:type "host" :path "."}
                                                   :language "python"
                                                   :script {:type "string" :data py-script}})

                ;; Read result file
                raw-output (pt/read-repo-file ".polytope-call-endpoint-result.json")
                result (pt/read-json raw-output)

                status (:status result)
                res-headers (:headers result)
                res-body (or (:body result) "")
                error (:error result)]

            ;; Clean up temp file
            (try
              (pt/call-module "pt/run-script" {:repo {:type "host" :path "."}
                                               :language "bash"
                                               :script {:type "string" :data "rm -f /repo/.polytope-call-endpoint-result.json"}})
              (catch Exception _))

            (when error
              (pt/fail (str "Connection failed for " url ". Error: " error)))

            (pt/log (str "Status: " status))
            (pt/log (str "Body: " (if (> (count (str res-body)) 2000)
                                    (str (subs (str res-body) 0 2000) "\n... (truncated)")
                                    res-body)))
            {:status status :headers res-headers :body res-body})
