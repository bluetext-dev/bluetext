tools:
  call-endpoint:
    info: |
      Makes HTTP requests to services running in the sandbox network.
      Use this instead of curl to reach services — it runs at the orchestrator level and can access the sandbox network directly.

      Provide either `service` (resolves host/port from values context) or `url` (raw URL). Not both.
      Note: Since requests run at the orchestrator level, `url` must use `localhost` with the exposed port (container hostnames like `python-fast-api` are not resolvable).

      Examples:
        call-endpoint(service: "python-fast-api", path: "/health")
        call-endpoint(service: "kong", path: "/api/users")
        call-endpoint(url: "http://localhost:3030/docs")
        call-endpoint(service: "python-fast-api", path: "/users", method: "POST", body: '{"name": "Alice"}')
    inputs:
      service:
        info: "Service name (e.g., python-fast-api, kong). Resolves host/port from values context."
        type: [default, str, ""]
      url:
        info: "Raw URL to call (must use localhost with the exposed port, e.g., http://localhost:3030/health). Container hostnames are not resolvable from the orchestrator."
        type: [default, str, ""]
      path:
        info: "Path to append when using service mode (e.g., /health, /api/users)."
        type: [default, str, "/"]
      method:
        info: "HTTP method."
        type: [default, [enum, GET, POST, PUT, PATCH, DELETE], GET]
      body:
        info: "Request body as a JSON string."
        type: [default, str, ""]
      headers:
        info: "Additional headers as a JSON object string (e.g., '{\"Authorization\": \"Bearer token\"}')."
        type: [default, str, ""]
    run:
      - id: make-request
        code: |-
          pt.clj
          (let [service (let [s (:service inputs)] (when (and s (not= s "")) s))
                raw-url (let [u (:url inputs)] (when (and u (not= u "")) u))
                path    (or (:path inputs) "/")
                method  (clojure.string/lower-case (or (:method inputs) "get"))
                body    (let [b (:body inputs)] (when (and b (not= b "")) b))
                hdrs    (let [h (:headers inputs)] (when (and h (not= h "")) h))

                ;; Validate: must provide service or url, not both
                _ (when (and (nil? service) (nil? raw-url))
                    (pt/fail "Must provide either 'service' or 'url'."))
                _ (when (and service raw-url)
                    (pt/fail "Provide either 'service' or 'url', not both."))

                ;; Helper: try to read a value, return nil if missing
                try-value (fn [k] (try (pt/value k) (catch Exception _ nil)))

                ;; Resolve URL
                ;; pt/http-request runs at the orchestrator level (outside containers),
                ;; so we use localhost with the exposed port to reach services.
                url (if service
                      (let [host (or (try-value (str service "-host")) "localhost")
                            port (or (try-value (str service "-http-port"))
                                     (try-value (str service "-proxy-port"))
                                     (try-value (str service "-port")))]
                        (when (nil? port)
                          (pt/fail (str "Could not resolve port for service '" service "'. Make sure the service is running and has registered its port in the values context.")))
                        (str "http://" host ":" port path))
                      raw-url)

                ;; Parse and validate headers
                parsed-headers (if hdrs
                                 (try
                                   (let [parsed (pt/read-json hdrs)]
                                     (if (map? parsed)
                                       parsed
                                       (pt/fail (str "Invalid 'headers' parameter: expected a JSON object, got " (type parsed) ". Example: '{\"Authorization\": \"Bearer token\"}'."))))
                                   (catch Exception _
                                     (pt/fail (str "Invalid 'headers' parameter: could not parse as JSON. Expected a JSON object string like '{\"Authorization\": \"Bearer token\"}', got: " hdrs))))
                                 {})
                final-headers (if body
                                (merge {"Content-Type" "application/json"} parsed-headers)
                                parsed-headers)

                ;; Build request
                request (cond-> {:method method :url url}
                          (seq final-headers) (assoc :headers final-headers)
                          body (assoc :body body))

                _ (pt/log (str method " " url))

                ;; Make the request with error handling for connection failures
                response (try
                           (pt/http-request request)
                           (catch Exception e
                             (pt/fail (str "Connection failed for " url "."
                                          (when raw-url " When using 'url', make sure to use localhost with the exposed port — container hostnames are not resolvable from the orchestrator.")
                                          " Error: " (.getMessage e)))))

                ;; Fail on connection errors (pt/http-request returns :error instead of throwing)
                _ (when (:error response)
                    (pt/fail (str "Connection failed for " url "."
                                  (when raw-url " When using 'url', make sure to use localhost with the exposed port — container hostnames are not resolvable from the orchestrator.")
                                  " Error: " (:error response))))

                status   (:status response)
                res-hdrs (:headers response)
                raw-body (:body response)
                ;; Serialize body and headers to EDN strings (write-json has a GraalVM reflection bug)
                res-body (if (or (map? raw-body) (sequential? raw-body))
                           (pr-str raw-body)
                           (str (or raw-body "")))
                res-hdrs-str (pr-str res-hdrs)]

            (pt/log (str "Status: " status))
            (pt/log (str "Headers: " res-hdrs-str))
            (pt/log (str "Body: " (if (> (count res-body) 2000)
                                    (str (subs res-body 0 2000) "\n... (truncated)")
                                    res-body)))
            {:status status :headers res-hdrs :body res-body})
