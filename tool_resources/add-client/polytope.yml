tools:
  add-client:
    info: |
      Adds a client to the project's clients directory.
      Scaffolds the client code and updates pyproject.toml with dependencies.

      Example: add-client(name: "couchbase", language: "python")
    inputs:
      name:
        info: Client name (e.g., "couchbase", "temporal", "jwt_validator", "phantom-token-handler")
        type: [enum, couchbase, temporal, jwt_validator, phantom-token-handler]
      language:
        info: Language for the client
        type: [default, [enum, python, typescript], python]
    run:
      # Inlined setup-project-structure logic (chained tool resolution broken in Polytope)
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-base-structure
          actions:
            - template: {type: repo, repo: "pt.clj pt/module-repo-ref", path: /tool_resources/setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "pt.clj pt/module-repo-ref", path: /tool_resources/setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "pt.clj pt/module-repo-ref", path: /tool_resources/setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "pt.clj pt/module-repo-ref", path: /tool_resources/setup-project-structure/base/config}
              path: config
              on-conflict: skip

      - id: scaffold-language
        after: {step: scaffold-base-structure}
        tool: polytope/scaffold
        args:
          container-id: scaffold-language
          actions:
            - template: {type: repo, repo: "pt.clj pt/module-repo-ref", path: "pt.clj (str \"/tool_resources/setup-project-structure/languages/clients/\" (:language inputs))"}
              path: "pt.clj (str \"clients/\" (:language inputs))"
              on-conflict: skip
            - template: {type: repo, repo: "pt.clj pt/module-repo-ref", path: "pt.clj (str \"/tool_resources/setup-project-structure/languages/models/\" (:language inputs))"}
              path: "pt.clj (str \"models/\" (:language inputs))"
              on-conflict: skip

      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ values.yml already in .gitignore"
              fi

              echo "‚úÖ .gitignore updated successfully"

      - id: scaffold-client
        after: {step: scaffold-language}
        tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "pt.clj pt/module-repo-ref", path: "pt.clj (str \"/tool_resources/add-client/\" (:language inputs) \"/\" (:name inputs) \"/template\")"}
              path: "pt.clj (str \"clients/\" (:language inputs) \"/clients/\" (:name inputs))"
              on-conflict: skip
      - id: update-pyproject
        after: {step: scaffold-client}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          script:
            type: string
            data: |
              import re
              from pathlib import Path

              name = "{pt.input name}"
              language = "{pt.input language}"

              # Define dependency mapping
              dependencies_map = {
                  "couchbase": "couchbase>=4.4.0",
                  "temporal": "temporalio>=1.6.0",
                  "jwt_validator": "PyJWT>=2.8.0",
              }

              # Get the dependency to add
              dependency = dependencies_map.get(name)
              if not dependency:
                  print(f"No dependency mapping found for {name}")
                  exit(0)

              # Path to pyproject.toml (scaffolded by the template)
              pyproject_path = Path(f"/repo/clients/{language}/pyproject.toml")

              # The pyproject.toml should have been scaffolded from the template
              if not pyproject_path.exists():
                  print(f"‚úÖ pyproject.toml was scaffolded with the client template")
                  exit(0)

              # Read the file
              content = pyproject_path.read_text()

              # Check if dependency already exists
              if dependency.split(">=")[0] in content:
                  print(f"‚úÖ Dependency {dependency} already exists in pyproject.toml")
                  exit(0)

              # Add dependency to the dependencies array
              # Find the dependencies section and add the new dependency
              pattern = r'(dependencies\s*=\s*\[)(.*?)(\])'

              def add_dependency(match):
                  deps_start = match.group(1)
                  deps_content = match.group(2)
                  deps_end = match.group(3)

                  # Add the new dependency
                  new_dep = f'\n    "{dependency}",'
                  return deps_start + deps_content + new_dep + '\n' + deps_end

              new_content = re.sub(pattern, add_dependency, content, flags=re.DOTALL)

              # Write back
              pyproject_path.write_text(new_content)
              print(f"‚úÖ Added {dependency} to pyproject.toml")

      - id: update-tsconfig
        after: {step: update-pyproject}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          script:
            type: string
            data: |
              import json
              from pathlib import Path

              name = "{pt.input name}"
              language = "{pt.input language}"

              if language != "typescript":
                  exit(0)

              tsconfig_path = Path(f"/repo/clients/{language}/tsconfig.json")
              if not tsconfig_path.exists():
                  print("‚ö†Ô∏è tsconfig.json not found")
                  exit(0)

              content = json.loads(tsconfig_path.read_text())

              # Ensure include array exists
              if "include" not in content:
                  content["include"] = []

              client_path = f"clients/{name}"
              if client_path not in content["include"]:
                  content["include"].append(client_path)
                  tsconfig_path.write_text(json.dumps(content, indent=2))
                  print(f"‚úÖ Added {client_path} to tsconfig.json include")
              else:
                  print(f"‚úÖ {client_path} already in tsconfig.json")

      # Inlined set-values-and-secrets logic (chained tool resolution broken in Polytope)
      - id: write-client-values-to-config
        after: {step: update-tsconfig}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /source-values.yml
              source:
                type: repo
                repo: "pt.clj pt/module-repo-ref"
                path: "pt.clj (str \"/tool_resources/set-values-and-secrets/add-client/\" (:name inputs) \"/values.yml\")"
            - path: /source-secrets.yml
              source:
                type: repo
                repo: "pt.clj pt/module-repo-ref"
                path: "pt.clj (str \"/tool_resources/set-values-and-secrets/add-client/\" (:name inputs) \"/secrets.yml\")"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path

              # Read source values and secrets from mounted files
              with open("/source-values.yml") as f:
                  new_values = yaml.safe_load(f) or {}

              with open("/source-secrets.yml") as f:
                  new_secrets = yaml.safe_load(f) or {}

              # Ensure config directory exists
              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Merge new values (new values take precedence)
              for k, v in new_values.items():
                  existing_values[k] = v

              for k, v in new_secrets.items():
                  existing_secrets[k] = v

              # Write values.yml with header
              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, 'w') as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                  # Force sort_keys=True
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                  # Force sort_keys=True
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f"‚úÖ Written {len(new_values)} values to config/values.yml")
              print(f"‚úÖ Written {len(new_secrets)} secrets to config/secrets.yml")

      # Read from user's config files (written by previous step) and set in Polytope runtime
      - id: set-client-values-in-runtime
        after: {step: write-client-values-to-config}
        code: |-
          pt.js
          // Read from user's config files that were written by the previous step
          const values = pt.readYaml(pt.readRepoFile("config/values.yml")) || {};
          const secrets = pt.readYaml(pt.readRepoFile("config/secrets.yml")) || {};

          pt.log(`üì¶ Setting ${Object.keys(values).length} values and ${Object.keys(secrets).length} secrets from config files`);

          for (const [k, v] of Object.entries(values)) {
            pt.log(`  Setting value: ${k} = ${v}`);
            pt.setProjectValue(k, String(v));
          }

          for (const [k, v] of Object.entries(secrets)) {
            pt.log(`  Setting secret: ${k} = ***`);
            pt.setSecret(k, String(v));
          }

          pt.log("‚úÖ Successfully set all client bindings");
