tools:
  add-client:
    info: |
      Adds a client to the project's clients directory.
      Scaffolds the client code and updates pyproject.toml with dependencies.

      Example: add-client(template: {couchbase: {}})
      This scaffolds a couchbase client to "clients/python/couchbase".

      Example: add-client(template: {python-fast-api: {upstream-service: "my-api"}})
      This scaffolds an API client to "clients/typescript/my-api-client".
    inputs:
      template:
        info: |
          Client template to scaffold. The key is the template name.
          For the "python-fast-api" template, provide upstream-service (the API service this client connects to).
        type:
          - either
          - couchbase: {}
          - postgres: {}
          - temporal: {}
          - jwt-validator: {}
          - twilio: {}
          - phantom-token-handler: {}
          - python-fast-api:
              upstream-service: str
    run:

      # Inlined setup-project-structure logic
      - id: scaffold-base-structure
        code: |-
          pt.js
          pt.callModule("polytope/scaffold", {
            "container-id": "scaffold-base-structure",
            actions: ["clients", "models", "services", "config"].map(dir => ({
              template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/setup-project-structure/base/${dir}` },
              path: dir,
              "on-conflict": "skip"
            }))
          });

      - id: scaffold-language
        after: {step: scaffold-base-structure}
        code: |-
          pt.js
          const templateObj = pt.param("template");
          const rawKey = Object.keys(templateObj)[0];
          const tmpl = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const langMap = {
            couchbase: "python", postgres: "python", temporal: "python",
            "jwt-validator": "python", twilio: "python",
            "python-fast-api": "typescript", "phantom-token-handler": "typescript"
          };
          const lang = langMap[tmpl];
          pt.callModule("polytope/scaffold", {
            "container-id": "scaffold-language",
            actions: [
              {
                template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/setup-project-structure/languages/clients/${lang}` },
                path: `clients/${lang}`,
                "on-conflict": "skip"
              },
              {
                template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/setup-project-structure/languages/models/${lang}` },
                path: `models/${lang}`,
                "on-conflict": "skip"
              }
            ]
          });

      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "âœ… secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "âœ… values.yml already in .gitignore"
              fi

              echo "âœ… .gitignore updated successfully"

      - id: scaffold-client
        after: {step: scaffold-language}
        code: |-
          pt.js
          const templateObj = pt.param("template");
          const rawKey = Object.keys(templateObj)[0];
          const tmpl = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const variables = templateObj[rawKey] || {};
          const langMap = {
            couchbase: "python", postgres: "python", temporal: "python",
            "jwt-validator": "python", twilio: "python",
            "python-fast-api": "typescript", "phantom-token-handler": "typescript"
          };
          const lang = langMap[tmpl];
          const resolvedName = (tmpl === "python-fast-api" && variables.upstreamService)
            ? `${variables.upstreamService}-client`
            : tmpl;
          pt.callModule("polytope/scaffold", {
            actions: [{
              template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/add-client/${lang}/${tmpl}/template` },
              path: `clients/${lang}/clients/${resolvedName}`,
              "on-conflict": "skip"
            }]
          });

      - id: update-pyproject
        after: {step: scaffold-client}
        code: |-
          pt.js
          const templateObj = pt.param("template");
          const rawKey = Object.keys(templateObj)[0];
          const tmpl = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const langMap = {
            couchbase: "python", postgres: "python", temporal: "python",
            "jwt-validator": "python", twilio: "python",
            "python-fast-api": "typescript", "phantom-token-handler": "typescript"
          };
          const lang = langMap[tmpl];

          if (lang !== "python") {
            pt.log("Skipping pyproject update for non-python client");
          } else {
            const depsMap = {
              couchbase: "couchbase>=4.4.0",
              temporal: "temporalio>=1.6.0",
              "jwt-validator": "PyJWT>=2.8.0",
            };
            const dep = depsMap[tmpl];
            if (!dep) {
              pt.log(`No dependency mapping for ${tmpl}`);
            } else {
              const script = `
          import re
          from pathlib import Path

          dep = "${dep}"
          pyproject_path = Path("/repo/clients/${lang}/pyproject.toml")

          if not pyproject_path.exists():
              print("pyproject.toml not found")
              exit(0)

          content = pyproject_path.read_text()
          if dep.split(">=")[0] in content:
              print(f"Dependency {dep} already exists")
              exit(0)

          pattern = r'(dependencies\\s*=\\s*\\[)(.*?)(\\])'
          def add_dep(m):
              return m.group(1) + m.group(2) + f'\\n    "{dep}",' + '\\n' + m.group(3)
          new_content = re.sub(pattern, add_dep, content, flags=re.DOTALL)
          pyproject_path.write_text(new_content)
          print(f"Added {dep} to pyproject.toml")
              `;
              pt.callModule("pt/run-script", {
                repo: { type: "host", path: "." },
                language: "python",
                script: { type: "string", data: script }
              });
            }
          }

      - id: update-tsconfig
        after: {step: update-pyproject}
        code: |-
          pt.js
          const templateObj = pt.param("template");
          const rawKey = Object.keys(templateObj)[0];
          const tmpl = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const variables = templateObj[rawKey] || {};
          const langMap = {
            couchbase: "python", postgres: "python", temporal: "python",
            "jwt-validator": "python", twilio: "python",
            "python-fast-api": "typescript", "phantom-token-handler": "typescript"
          };
          const lang = langMap[tmpl];

          if (lang !== "typescript") {
            pt.log("Skipping tsconfig update for non-typescript client");
          } else {
            const resolvedName = (tmpl === "python-fast-api" && variables.upstreamService)
              ? `${variables.upstreamService}-client`
              : tmpl;
            const script = `
          import json
          from pathlib import Path

          resolved_name = "${resolvedName}"
          tsconfig_path = Path("/repo/clients/typescript/tsconfig.json")

          if not tsconfig_path.exists():
              print("tsconfig.json not found")
              exit(0)

          content = json.loads(tsconfig_path.read_text())
          if "include" not in content:
              content["include"] = []

          client_path = f"{resolved_name}"
          if client_path not in content["include"]:
              content["include"].append(client_path)
              tsconfig_path.write_text(json.dumps(content, indent=2))
              print(f"Added {client_path} to tsconfig.json include")
          else:
              print(f"{client_path} already in tsconfig.json")
            `;
            pt.callModule("pt/run-script", {
              repo: { type: "host", path: "." },
              language: "python",
              script: { type: "string", data: script }
            });
          }

      # Inlined set-values-and-secrets logic
      - id: write-client-values-to-config
        after: {step: update-tsconfig}
        code: |-
          pt.js
          const templateObj = pt.param("template");
          const rawKey = Object.keys(templateObj)[0];
          const tmpl = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");

          // Read source values/secrets from module repo
          let sourceValues = "";
          let sourceSecrets = "";
          try {
            sourceValues = pt.readRepoFile(
              `tool_resources/set-values-and-secrets/add-client/${tmpl}/values.yml`,
              { repo: pt.moduleRepoRef }
            );
          } catch (e) { pt.log("No source values.yml found"); }
          try {
            sourceSecrets = pt.readRepoFile(
              `tool_resources/set-values-and-secrets/add-client/${tmpl}/secrets.yml`,
              { repo: pt.moduleRepoRef }
            );
          } catch (e) { pt.log("No source secrets.yml found"); }

          const escValues = sourceValues.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
          const escSecrets = sourceSecrets.replace(/\\/g, "\\\\").replace(/'/g, "\\'");

          const script = `
          import yaml
          from pathlib import Path

          new_values = yaml.safe_load('''${escValues}''') or {}
          new_secrets = yaml.safe_load('''${escSecrets}''') or {}

          config_dir = Path('/repo/config')
          config_dir.mkdir(parents=True, exist_ok=True)

          values_file = config_dir / 'values.yml'
          secrets_file = config_dir / 'secrets.yml'

          existing_values = yaml.safe_load(open(values_file).read()) if values_file.exists() else {}
          existing_values = existing_values or {}
          existing_secrets = yaml.safe_load(open(secrets_file).read()) if secrets_file.exists() else {}
          existing_secrets = existing_secrets or {}

          existing_values.update(new_values)
          existing_secrets.update(new_secrets)

          with open(values_file, 'w') as f:
              f.write('# Configuration values\\n# Generated and managed by Bluetext tools\\n\\n')
              if existing_values:
                  yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

          with open(secrets_file, 'w') as f:
              f.write('# Configuration secrets\\n# Add this file to .gitignore\\n# Generated and managed by Bluetext tools\\n\\n')
              if existing_secrets:
                  yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

          print(f'Written {len(new_values)} values and {len(new_secrets)} secrets to config/')
          `;

          pt.callModule("pt/run-script", {
            repo: { type: "host", path: "." },
            language: "python",
            dependencies: ["pyyaml"],
            script: { type: "string", data: script }
          });

      # Read from user's config files (written by previous step) and set in Polytope runtime
      - id: set-client-values-in-runtime
        after: {step: write-client-values-to-config}
        code: |-
          pt.js
          // Read from user's config files that were written by the previous step
          const values = pt.readYaml(pt.readRepoFile("config/values.yml")) || {};
          const secrets = pt.readYaml(pt.readRepoFile("config/secrets.yml")) || {};

          pt.log(`ðŸ“¦ Setting ${Object.keys(values).length} values and ${Object.keys(secrets).length} secrets from config files`);

          for (const [k, v] of Object.entries(values)) {
            pt.log(`  Setting value: ${k} = ${v}`);
            pt.setProjectValue(k, String(v));
          }

          for (const [k, v] of Object.entries(secrets)) {
            pt.log(`  Setting secret: ${k} = ***`);
            pt.setSecret(k, String(v));
          }

          pt.log("âœ… Successfully set all client bindings");
