instructions: |
  **FIRST ACTION**: Before doing ANYTHING else, retrieve AI development context for the relevant scope:
  ```mcp
  __polytope__initialize_session()
  ```
  This is MANDATORY as your first action in every conversation. It provides guidelines that you must follow.

include:
  - implement/polytope.yml
  - setup-environment-variables/polytope.yml

tools:

  stack:
    run:
      - tool: polytope/hello-world
        args:
          message: Nothing to run yet! Call an "add" tool, to add a components to your project.

  scaffold-initialize-session:
    run:
      - tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/sh
              set -e

              TARGET_FILE="${1:-polytope.yml}"

              if [ ! -f "$TARGET_FILE" ]; then
                echo "Error: File $TARGET_FILE not found"
                exit 1
              fi

              # Check if tools block exists
              if ! grep -q "^tools:" "$TARGET_FILE"; then
                echo "Adding tools block to $TARGET_FILE"
                echo "" >> "$TARGET_FILE"
                echo "tools:" >> "$TARGET_FILE"
              fi

              # Check if initialize_session already exists
              if grep -q "^  initialize_session:" "$TARGET_FILE" || grep -q "^    initialize_session:" "$TARGET_FILE"; then
                echo "initialize_session already exists in $TARGET_FILE"
                exit 0
              fi

              # Append initialize_session tool
              echo "Adding initialize_session tool to $TARGET_FILE"
              cat >> "$TARGET_FILE" << 'EOF'

                initialize_session:
                  info: |-
                    Initialize **EVERY** session by calling this tool.
                    Returns required development context and ensures the project is running.
                    This tool always needs to be called before doing anything else, regardless of the tasks complexity.
                  run:
                    - id: get-general-context
                      tool: get_dev_context
                    - id: apply-stack-and-await-finish
                      tool: "stack"
              EOF

              echo "Successfully added initialize_session to $TARGET_FILE"

  load-config:
    info: |
      Loads configuration from config/values.yml and config/secrets.yml into the Polytope context.
      Useful for initializing the session with existing configuration.
    run:
      - id: load-values-and-secrets
        code: |-
          #pt-clj
          (let [container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                        :id "load-config-ctx"
                                        :restart {:policy "never"}
                                        :mounts [{:path "/values.yml"
                                                  :source {:type "host"
                                                           :path "config/values.yml"}}
                                                 {:path "/secrets.yml"
                                                  :source {:type "host"
                                                           :path "config/secrets.yml"}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            (try
              (let [values-content (pt/read-container-file container-id "/values.yml")
                    values (pt/read-yaml values-content)]
                (pt/log (str "üì¶ Loading " (count values) " values from config/values.yml"))
                (doseq [[k v] values]
                  (pt/log (str "  Setting value: " (name k) " = " v))
                  (pt/set-project-value (name k) (str v))))
              (catch Exception e
                (pt/log "‚ÑπÔ∏è No config/values.yml found or could not be read.")))
            (try
              (let [secrets-content (pt/read-container-file container-id "/secrets.yml")
                    secrets (pt/read-yaml secrets-content)]
                (pt/log (str "üîê Loading " (count secrets) " secrets from config/secrets.yml"))
                (doseq [[k v] secrets]
                  (pt/log (str "  Setting secret: " (name k) " = ***"))
                  (pt/set-secret (name k) (str v))))
              (catch Exception e
                (pt/log "‚ÑπÔ∏è No config/secrets.yml found or could not be read.")))
            (pt/stop {:type "container" :ref container-id}))

  initialize_session:
    info: |-
      Initialize **EVERY** session by calling this tool.
      Returns required development context and ensures the project is running.
      This tool always needs to be called before doing anything else, regardless of the tasks complexity.
    await: [return-context]
    run:
      - id: scaffold-local-overwrite
        tool: scaffold-initialize-session
      - id: attempt-run-local-stack
        after:
          - step: scaffold-local-overwrite
        tool: stack
      - id: return-context
        after:
          - step: scaffold-local-overwrite
        tool: get_dev_context

  get_dev_context:
    info: |
      Outputs development guidelines for a specific scope.
      Call this tool to get detailed documentation about models, clients, api, or frontend.
      If no scope is provided, returns general development context.
    params:
      - id: scope
        info: "The scope to fetch (optional, defaults to general context)"
        type: [default, [enum, general, models, clients, api, frontend], general]
    run:
      - id: get_dev_context
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          mounts:
            - { path: /general.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: initialize-session/context.md } }
            - { path: /models.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models/README.md } }
            - { path: /clients.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients/README.md } }
            - { path: /api.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: scopes/api.md } }
            - { path: /frontend.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: scopes/frontend.md } }
          script:
            type: string
            data: |
              #!/bin/bash
              SCOPE="{pt.param scope}"
              case "$SCOPE" in
                models) cat /models.md ;;
                clients) cat /clients.md ;;
                api) cat /api.md ;;
                frontend) cat /frontend.md ;;
                *) cat /general.md ;;
              esac

  # add-dependencies:
  #   info: |
  #     Adds packages to a service's dependency file.
  #     Automatically detects the package manager for the target service.
  #   params:
  #     - id: target
  #       info: The service to add dependencies to (e.g., api, frontend)
  #       type: str
  #     - id: packages
  #       info: Packages to add (comma or space separated)
  #       type: str
  #   run:
  #     - id: run-add-deps
  #       code: |
  #         #pt-clj
  #         (let [target (:target params)
  #               packages (clojure.string/replace (:packages params) #"[\s,]+" " ")
  #               [cmd restart-policy] (case target
  #                                      "api" [(str "./bin/add-dependencies " packages) "never"]
  #                                      "frontend" [(str "bun add " packages) "on-failure"]
  #                                      (throw (Exception. (str "Unknown target: " target))))]
  #           (pt/call-module target {:id (str target "-add-deps")
  #                                  :cmd cmd
  #                                  :restart-policy restart-policy
  #                                  :create "always"}))

  setup-project-structure:
    info: |
      Sets up the base directory structure for a Bluetext project.
      Projects are organised by models, services, and clients.
    params:
      - id: language
        info: Language to scaffold (python).
        type: [enum, python]
      - id: skip-language
        info: Skip scaffolding language-specific structure even if language is provided
        type: [default, bool, false]
    run:
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/config}
              path: config
              on-conflict: skip
      - id: scaffold-language
        after: {step: scaffold-base-structure}
        tool: polytope/scaffold
        args:
          container-id: scaffold-language
          actions: |-
            #pt-clj
            (if (and (:language params) (not (:skip-language params)))
              [{:template {:type "repo" :repo pt/module-repo-ref :path (str "tool_resources/setup-project-structure/languages/clients/" (:language params))}
                :path (str "clients/" (:language params))
                :on-conflict "skip"}
               {:template {:type "repo" :repo pt/module-repo-ref :path (str "tool_resources/setup-project-structure/languages/models/" (:language params))}
                :path (str "models/" (:language params))
                :on-conflict "skip"}]
              [])
      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ values.yml already in .gitignore"
              fi

              echo "‚úÖ .gitignore updated successfully"

  add-and-run-service:
    info: |
      Scaffolds a service, adds it to includes, adds it to a run graph, and optionally runs it.
      This is a convenience tool that combines scaffold and add-to-run-graph.

      Example: add-and-run-service(template: "api", name: "my-api", run: true)
      This scaffolds to "services/my-api", adds it to stack, and runs it.
    params:
      - id: template
        info: Template to scaffold
        type: [enum, api_python_fastapi, frontend_typescript_react-router-v7, couchbase-server_enterprise-v7, temporal, temporal-ui, postgres, curity, kong]
      - id: name
        info: Service name (e.g., "my-api"). Will be scaffolded to "services/<name>"
        type: str
      - id: target
        info: Which graph/tool to add to
        type: [default, str, stack]
      - id: run
        info: Whether to run the service after adding
        type: [default, bool, true]
      - id: version
        info: Optional version tag for the service image (e.g. "3.4"). If provided, it overrides the default image tag.
        type: [maybe, str]
      - id: on-conflict
        info: What to do if files already exist
        type: [default, [enum, skip, overwrite], skip]
    run:

      # Inlined setup-project-structure logic (chained tool resolution broken in Polytope)
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-base-structure
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/config}
              path: config
              on-conflict: skip

      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ values.yml already in .gitignore"
              fi


      - id: ensure-load-config-in-stack
        after: {step: update-gitignore}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path
              import sys

              target_file = Path("polytope.yml")

              if not target_file.exists():
                  print("polytope.yml not found, skipping stack update")
                  sys.exit(0)

              with open(target_file, 'r') as f:
                  try:
                      config = yaml.safe_load(f) or {}
                  except yaml.YAMLError as exc:
                      print(f"Error parsing polytope.yml: {exc}")
                      sys.exit(1)

              if 'tools' not in config:
                  config['tools'] = {}

              tools = config['tools']

              # Ensure load-config definition exists (optional, if we assume it's external)
              # For now, we assume load-config is available via the environment/framework.

              # Check/Create stack tool
              if 'stack' not in tools:
                  print("Creating stack tool...")
                  tools['stack'] = {
                      'run': [
                          {'tool': 'load-config'}
                      ]
                  }
              else:
                  stack_run = tools['stack'].get('run', [])
                  if not stack_run:
                      stack_run = []
                      tools['stack']['run'] = stack_run
                  
                  # Check if load-config is already called
                  has_load_config = False
                  for step in stack_run:
                      if isinstance(step, dict) and step.get('tool') == 'load-config':
                          has_load_config = True
                          break
                  
                  if not has_load_config:
                      print("Adding load-config to stack...")
                      # Prepend load-config
                      tools['stack']['run'].insert(0, {'tool': 'load-config'})
                  else:
                      print("stack already has load-config")

              with open(target_file, 'w') as f:
                  yaml.dump(config, f, default_flow_style=False, sort_keys=False)

      - id: read-dependencies
        after: {step: scaffold-base-structure}
        code: |-
          #pt-clj
          (let [template (:template params)
                deps-path (str "tool_resources/add-and-run-service/" template "/dependencies.yml")
                container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                        :id (str "read-deps-" template)
                                        :restart {:policy "never"}
                                        :mounts [{:path "/dependencies.yml"
                                                  :source {:type "repo"
                                                           :repo pt/module-repo-ref
                                                           :path deps-path}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            (let [content (pt/read-container-file container-id "/dependencies.yml")
                  data (pt/read-yaml content)
                  deps (or (:dependencies data) [])
                  lang (:language data)]
              (pt/log (str "üì¶ Found " (count deps) " dependencies for " template (when lang (str ", language: " lang))))
              (pt/stop {:type "container" :ref container-id})
              ;; Scaffold language directories if specified
              (when lang
                (pt/call-module "_scaffold-language" {:language lang}))
              ;; Handle dependency scaffolding inline to avoid pt.output issues
              ;; Running deps and setting values are handled by separate steps (which read deps inline too)
              (when (seq deps)
                (pt/call-module "_scaffold-deps" {:deps deps
                                                   :on-conflict (:on-conflict params)
                                                   :target (:target params)}))
              {:dependencies deps :language lang}))

      - id: scaffold-services
        after: {step: read-dependencies}
        tool: polytope/scaffold
        args:
          container-id: "#pt-clj (str \"scaffold-services-\" (:template params))"
          actions: |-
            #pt-clj
            (let [template (:template params)
                  name (-> (:name params)
                           clojure.string/lower-case
                           (clojure.string/replace #"[^a-z0-9_-]" "-"))
                  on-conflict (:on-conflict params)
                  target (:target params)]
              [{:template {:type "repo" :repo pt/module-repo-ref :path (str "tool_resources/add-and-run-service/" template "/template")}
                :path (str "services/" name)
                :on-conflict on-conflict
                :add-to-tools [{:tool target :call name}]}])

      # Inlined set-values-and-secrets logic (chained tool resolution broken in Polytope)
      - id: apply-service-version
        after: {step: scaffold-services}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path
              import sys
              import re

              version = "{pt.param version}"
              if not version or version == "null" or version == "":
                  print("No version specified, skipping version application")
                  sys.exit(0)

              name = "{pt.param name}".lower().replace(" ", "-")
              # Calculate sanitized name logic same as clojure: replace non-alphanum with -
              name = re.sub(r"[^a-z0-9_-]", "-", name)
              
              service_polytope_file = Path(f"services/{name}/polytope.yml")
              
              if not service_polytope_file.exists():
                  print(f"Service polytope file {service_polytope_file} not found")
                  sys.exit(0)

              print(f"Applying version {version} to {service_polytope_file}")

              with open(service_polytope_file, 'r') as f:
                  try:
                      config = yaml.safe_load(f) or {}
                  except yaml.YAMLError as exc:
                      print(f"Error parsing polytope.yml: {exc}")
                      sys.exit(1)

              updated = False
              
              # Traverse tools and find arguments with 'image'
              tools = config.get('tools', {})
              for tool_name, tool_def in tools.items():
                  run_steps = tool_def.get('run', [])
                  if isinstance(run_steps, dict): # Should be list, but sometimes single object allowed? Standard is list.
                       run_steps = [run_steps]
                  
                  for step in run_steps:
                      if isinstance(step, dict):
                          args = step.get('args', {})
                          image = args.get('image')
                          if image and isinstance(image, str):
                              # Replace tag (after last :) or append if no tag
                              if ':' in image:
                                  base_image = image.rsplit(':', 1)[0]
                                  new_image = f"{base_image}:{version}"
                              else:
                                  new_image = f"{image}:{version}"
                              
                              if new_image != image:
                                  args['image'] = new_image
                                  updated = True
                                  print(f"Updated image to {new_image}")

              if updated:
                  with open(service_polytope_file, 'w') as f:
                      yaml.dump(config, f, default_flow_style=False, sort_keys=False)
                  print("‚úÖ Successfully updated service version")
              else:
                  print("No image fields found to update")

      - id: write-service-values-to-config
        after: {step: apply-service-version}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /source-values.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"tool_resources/set-values-and-secrets/add-and-run-service/\" (:template params) \"/values.yml\")"
            - path: /source-secrets.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"tool_resources/set-values-and-secrets/add-and-run-service/\" (:template params) \"/secrets.yml\")"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path
              import os

              run = "{pt.param run}"
              if run != "true":
                  print("Skipping - run is not enabled")
                  exit(0)

              # Read source values and secrets from mounted files
              with open("/source-values.yml") as f:
                  new_values = yaml.safe_load(f) or {}

              with open("/source-secrets.yml") as f:
                  new_secrets = yaml.safe_load(f) or {}

              # Ensure config directory exists
              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Merge new values (new values take precedence)
              for k, v in new_values.items():
                  existing_values[k] = v

              for k, v in new_secrets.items():
                  existing_secrets[k] = v

              # Write values.yml with header
              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, 'w') as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f"‚úÖ Written {len(new_values)} values to config/values.yml")
              print(f"‚úÖ Written {len(new_secrets)} secrets to config/secrets.yml")



      # Inlined _set-values-for-deps logic (chained tool resolution broken in Polytope)
      - id: write-deps-values-to-config
        after: {step: read-dependencies}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /dependencies.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"tool_resources/add-and-run-service/\" (:template params) \"/dependencies.yml\")"
            - path: /service-configs
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: tool_resources/set-values-and-secrets/add-and-run-service
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path

              run_enabled = "{pt.param run}"
              if run_enabled != "true":
                  print("Skipping - run is not enabled")
                  exit(0)

              # Read dependencies from mounted file
              with open("/dependencies.yml") as f:
                  deps_data = yaml.safe_load(f) or {}

              deps = deps_data.get("dependencies", [])
              if not deps:
                  print("No dependencies to process")
                  exit(0)

              # Ensure config directory exists
              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Process each dependency
              for dep in deps:
                  dep_name = dep.get("name")
                  if not dep_name:
                      continue

                  values_path = Path(f"/service-configs/{dep_name}/values.yml")
                  secrets_path = Path(f"/service-configs/{dep_name}/secrets.yml")

                  if values_path.exists():
                      with open(values_path) as f:
                          new_values = yaml.safe_load(f) or {}
                      for k, v in new_values.items():
                          existing_values[k] = v
                      print(f"Merged {len(new_values)} values for {dep_name}")
                  else:
                      print(f"No values.yml found for {dep_name}")

                  if secrets_path.exists():
                      with open(secrets_path) as f:
                          new_secrets = yaml.safe_load(f) or {}
                      for k, v in new_secrets.items():
                          existing_secrets[k] = v
                      print(f"Merged {len(new_secrets)} secrets for {dep_name}")
                  else:
                      print(f"No secrets.yml found for {dep_name}")

              # Write values.yml with header
              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, "w") as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, "w") as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f"Written all dependency values to config/values.yml")
              print(f"Written all dependency secrets to config/secrets.yml")



      - id: copy-config-files
        after: {step: write-deps-values-to-config}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /dependencies.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"tool_resources/add-and-run-service/\" (:template params) \"/dependencies.yml\")"
            - path: /tool-resources
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: tool_resources/add-and-run-service
          script:
            type: string
            data: |
              import yaml
              import shutil
              from pathlib import Path
              import os

              run_enabled = "{pt.param run}"
              if run_enabled != "true":
                  print("Skipping - run is not enabled")
                  exit(0)

              repo_config_dir = Path("/repo/config")
              repo_config_dir.mkdir(parents=True, exist_ok=True)

              # 1. Copy from the service itself
              template = "{pt.param template}"
              service_config_dir = Path(f"/tool-resources/{template}/config")
              if service_config_dir.exists() and service_config_dir.is_dir():
                  print(f"Found config templates for {template} at {service_config_dir}")
                  for item in service_config_dir.iterdir():
                      if item.is_file():
                          target_file = repo_config_dir / item.name
                          shutil.copy2(item, target_file)
                          print(f"‚úÖ Copied {item.name} to config/")
              
              # 2. Copy from recursively resolved dependencies
              visited = set()
              
              def collect_dependencies(deps_list):
                  results = []
                  for dep in deps_list:
                      dep_name = dep.get("name")
                      if not dep_name or dep_name in visited:
                          continue
                      
                      visited.add(dep_name)
                      results.append(dep)
                      
                      # Check for nested dependencies
                      dep_path = dep.get("path", dep_name)
                      dep_deps_file = Path(f"/tool-resources/{dep_path}/dependencies.yml")
                      
                      if dep_deps_file.exists():
                          try:
                              with open(dep_deps_file) as f:
                                  nested_data = yaml.safe_load(f) or {}
                                  nested_deps = nested_data.get("dependencies", [])
                                  if nested_deps:
                                      print(f"üîé Found nested dependencies for {dep_name}: {[d.get('name') for d in nested_deps]}")
                                      results.extend(collect_dependencies(nested_deps))
                          except Exception as e:
                              print(f"‚ö†Ô∏è Could not read dependencies for {dep_name}: {e}")
                  return results

              # Initial dependencies from the mounted file
              with open("/dependencies.yml") as f:
                  initial_data = yaml.safe_load(f) or {}
              
              initial_deps = initial_data.get("dependencies", [])
              all_deps = collect_dependencies(initial_deps)

              if all_deps:
                  print(f"üì¶ Processing {len(all_deps)} unique dependencies")
                  for dep in all_deps:
                      dep_name = dep.get("name")
                      dep_path = dep.get("path", dep_name)

                      # Check for tool_resources/{dep}/config
                      source_config_dir = Path(f"/tool-resources/{dep_path}/config")
                      if source_config_dir.exists() and source_config_dir.is_dir():
                          print(f"Found config templates for dependency {dep_name} at {source_config_dir}")
                          for item in source_config_dir.iterdir():
                              if item.is_file():
                                  target_file = repo_config_dir / item.name
                                  shutil.copy2(item, target_file)
                                  print(f"‚úÖ Copied {item.name} to config/ (from dependency {dep_name})")
                      else:
                          print(f"No config templates found for dependency {dep_name}")

      - id: run-stack
        after:
          - step: write-service-values-to-config
          - step: write-deps-values-to-config
          - step: copy-config-files
        code: |
          #pt-clj
          (when (:run params)
            (let [target (:target params)]
              (pt/log (str "üöÄ Running execution graph: " target))
              (pt/call-module target {})))


  add-project-language:
    info: |
      Adds language-specific client and model libraries to the project.
      Run setup-project-structure first if you haven't already.

      This creates language-specific library structures in:
      - clients/<language>/
      - models/<language>/
    params:
      - id: language
        info: Language to add (currently only supports python)
        type: [enum, python]
    run:
      - tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/clients/\" (:language params))"}
              path: "#pt-clj (str \"clients/\" (:language params))"
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/models/\" (:language params))"}
              path: "#pt-clj (str \"models/\" (:language params))"
              on-conflict: skip

  add-client:
    info: |
      Adds a client to the project's clients directory.
      Scaffolds the client code and updates pyproject.toml with dependencies.

      Example: add-client(name: "couchbase", language: "python")
    params:
      - id: name
        info: Client name (e.g., "couchbase", "temporal", "jwt_validator", "phantom-token-handler")
        type: [enum, couchbase, temporal, jwt_validator, phantom-token-handler]
      - id: language
        info: Language for the client
        type: [default, [enum, python, typescript], python]
    run:
      # Inlined setup-project-structure logic (chained tool resolution broken in Polytope)
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-base-structure
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/config}
              path: config
              on-conflict: skip

      - id: scaffold-language
        after: {step: scaffold-base-structure}
        tool: polytope/scaffold
        args:
          container-id: scaffold-language
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/clients/\" (:language params))"}
              path: "#pt-clj (str \"clients/\" (:language params))"
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/models/\" (:language params))"}
              path: "#pt-clj (str \"models/\" (:language params))"
              on-conflict: skip

      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ values.yml already in .gitignore"
              fi

              echo "‚úÖ .gitignore updated successfully"

      - id: scaffold-client
        after: {step: scaffold-language}
        tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"add-client/\" (:language params) \"/\" (:name params) \"/template\")"}
              path: "#pt-clj (str \"clients/\" (:language params) \"/clients/\" (:name params))"
              on-conflict: skip
      - id: update-pyproject
        after: {step: scaffold-client}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          script:
            type: string
            data: |
              import re
              from pathlib import Path

              name = "{pt.param name}"
              language = "{pt.param language}"

              # Define dependency mapping
              dependencies_map = {
                  "couchbase": "couchbase>=4.4.0",
                  "temporal": "temporalio>=1.6.0",
                  "jwt_validator": "PyJWT>=2.8.0",
              }

              # Get the dependency to add
              dependency = dependencies_map.get(name)
              if not dependency:
                  print(f"No dependency mapping found for {name}")
                  exit(0)

              # Path to pyproject.toml (scaffolded by the template)
              pyproject_path = Path(f"/repo/clients/{language}/pyproject.toml")

              # The pyproject.toml should have been scaffolded from the template
              if not pyproject_path.exists():
                  print(f"‚úÖ pyproject.toml was scaffolded with the client template")
                  exit(0)

              # Read the file
              content = pyproject_path.read_text()

              # Check if dependency already exists
              if dependency.split(">=")[0] in content:
                  print(f"‚úÖ Dependency {dependency} already exists in pyproject.toml")
                  exit(0)

              # Add dependency to the dependencies array
              # Find the dependencies section and add the new dependency
              pattern = r'(dependencies\s*=\s*\[)(.*?)(\])'

              def add_dependency(match):
                  deps_start = match.group(1)
                  deps_content = match.group(2)
                  deps_end = match.group(3)

                  # Add the new dependency
                  new_dep = f'\n    "{dependency}",'
                  return deps_start + deps_content + new_dep + '\n' + deps_end

              new_content = re.sub(pattern, add_dependency, content, flags=re.DOTALL)

              # Write back
              pyproject_path.write_text(new_content)
              print(f"‚úÖ Added {dependency} to pyproject.toml")

      - id: update-tsconfig
        after: {step: update-pyproject}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          script:
            type: string
            data: |
              import json
              from pathlib import Path

              name = "{pt.param name}"
              language = "{pt.param language}"

              if language != "typescript":
                  exit(0)

              tsconfig_path = Path(f"/repo/clients/{language}/tsconfig.json")
              if not tsconfig_path.exists():
                  print("‚ö†Ô∏è tsconfig.json not found")
                  exit(0)

              content = json.loads(tsconfig_path.read_text())
              
              # Ensure include array exists
              if "include" not in content:
                  content["include"] = []
              
              client_path = f"clients/{name}"
              if client_path not in content["include"]:
                  content["include"].append(client_path)
                  tsconfig_path.write_text(json.dumps(content, indent=2))
                  print(f"‚úÖ Added {client_path} to tsconfig.json include")
              else:
                  print(f"‚úÖ {client_path} already in tsconfig.json")

      # Inlined set-values-and-secrets logic (chained tool resolution broken in Polytope)
      - id: write-client-values-to-config
        after: {step: update-tsconfig}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /source-values.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"set-values-and-secrets/add-client/\" (:name params) \"/values.yml\")"
            - path: /source-secrets.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"set-values-and-secrets/add-client/\" (:name params) \"/secrets.yml\")"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path

              # Read source values and secrets from mounted files
              with open("/source-values.yml") as f:
                  new_values = yaml.safe_load(f) or {}

              with open("/source-secrets.yml") as f:
                  new_secrets = yaml.safe_load(f) or {}

              # Ensure config directory exists
              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Merge new values (new values take precedence)
              for k, v in new_values.items():
                  existing_values[k] = v

              for k, v in new_secrets.items():
                  existing_secrets[k] = v

              # Write values.yml with header
              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, 'w') as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f"‚úÖ Written {len(new_values)} values to config/values.yml")
              print(f"‚úÖ Written {len(new_secrets)} secrets to config/secrets.yml")

      - id: set-client-values-in-runtime
        after: {step: write-client-values-to-config}
        code: |-
          #pt-clj
          (let [client-name (:name params)
                safe-id (clojure.string/replace client-name #"[^a-z0-9-]" "-")
                values-path (str "tool_resources/set-values-and-secrets/add-client/" client-name "/values.yml")
                secrets-path (str "tool_resources/set-values-and-secrets/add-client/" client-name "/secrets.yml")
                container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                        :id (str "set-client-vals-" safe-id)
                                        :restart {:policy "never"}
                                        :mounts [{:path "/values.yml"
                                                  :source {:type "repo"
                                                           :repo pt/module-repo-ref
                                                           :path values-path}}
                                                 {:path "/secrets.yml"
                                                  :source {:type "repo"
                                                           :repo pt/module-repo-ref
                                                           :path secrets-path}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            (let [values-content (pt/read-container-file container-id "/values.yml")
                  secrets-content (pt/read-container-file container-id "/secrets.yml")
                  values (pt/read-yaml values-content)
                  secrets (pt/read-yaml secrets-content)]
              (pt/log (str "üì¶ Setting " (count values) " values and " (count secrets) " secrets from source files"))
              (doseq [[k v] values]
                (pt/log (str "  Setting value: " (name k) " = " v))
                (pt/set-project-value (name k) (str v)))
              (doseq [[k v] secrets]
                (pt/log (str "  Setting secret: " (name k) " = ***"))
                (pt/set-secret (name k) (str v)))
              (pt/log "‚úÖ Successfully set all client bindings")
              (pt/stop {:type "container" :ref container-id})))

  set-values-and-secrets:
    info: |
      Sets values and secrets using pt.setValue and pt.setSecret.
      Reads from pre-existing values.yml and secrets.yml files in set-values-and-secrets/add-client/{source}/ or set-values-and-secrets/add-and-run-service/{source}/.
      Also writes the values to the user's config/values.yml and config/secrets.yml files.
      This must be called before setup-service-for-client.
    params:
      - id: source
        info: Source to configure (service, client name, or implement path)
        type: str
    run:
      # Step 1: Write values to user's config files (merge with existing)
      - id: write-to-config-files
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /source-values.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (let [source (:source params)] (cond (clojure.string/starts-with? source \"implement/\") (str \"set-values-and-secrets/\" source \"/values.yml\") (clojure.string/ends-with? source \"-client\") (str \"set-values-and-secrets/add-client/\" (clojure.string/replace source #\"-client$\" \"\") \"/values.yml\") :else (str \"set-values-and-secrets/add-and-run-service/\" source \"/values.yml\")))"
            - path: /source-secrets.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (let [source (:source params)] (cond (clojure.string/starts-with? source \"implement/\") (str \"set-values-and-secrets/\" source \"/secrets.yml\") (clojure.string/ends-with? source \"-client\") (str \"set-values-and-secrets/add-client/\" (clojure.string/replace source #\"-client$\" \"\") \"/secrets.yml\") :else (str \"set-values-and-secrets/add-and-run-service/\" source \"/secrets.yml\")))"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path

              source = "{pt.param source}"

              # Read source values and secrets from mounted files
              with open("/source-values.yml") as f:
                  new_values = yaml.safe_load(f) or {}

              with open("/source-secrets.yml") as f:
                  new_secrets = yaml.safe_load(f) or {}

              # Ensure config directory exists
              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Merge new values (new values take precedence)
              for k, v in new_values.items():
                  existing_values[k] = v

              for k, v in new_secrets.items():
                  existing_secrets[k] = v

              # Write values.yml with header
              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, 'w') as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f"‚úÖ Written {len(new_values)} values to config/values.yml")
              print(f"‚úÖ Written {len(new_secrets)} secrets to config/secrets.yml")

      # Step 2: Read from source files and set in Polytope runtime
      - id: set-from-config-files
        after: {step: write-to-config-files}
        code: |-
          #pt-clj
          (let [source (:source params)
                safe-id (clojure.string/replace source #"[^a-z0-9-]" "-")
                base-path (cond
                            (clojure.string/starts-with? source "implement/")
                              (str "tool_resources/set-values-and-secrets/" source)
                            (clojure.string/ends-with? source "-client")
                              (str "tool_resources/set-values-and-secrets/add-client/" (clojure.string/replace source #"-client$" ""))
                            :else
                              (str "tool_resources/set-values-and-secrets/add-and-run-service/" source))
                values-path (str base-path "/values.yml")
                secrets-path (str base-path "/secrets.yml")
                container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                        :id (str "set-vals-" safe-id)
                                        :restart {:policy "never"}
                                        :mounts [{:path "/values.yml"
                                                  :source {:type "repo"
                                                           :repo pt/module-repo-ref
                                                           :path values-path}}
                                                 {:path "/secrets.yml"
                                                  :source {:type "repo"
                                                           :repo pt/module-repo-ref
                                                           :path secrets-path}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            (let [values-content (pt/read-container-file container-id "/values.yml")
                  secrets-content (pt/read-container-file container-id "/secrets.yml")
                  values (pt/read-yaml values-content)
                  secrets (pt/read-yaml secrets-content)]
              (pt/log (str "üì¶ Setting " (count values) " values and " (count secrets) " secrets from source files"))
              ;; Set values in Polytope runtime
              (doseq [[k v] values]
                (pt/log (str "  Setting value: " (name k) " = " v))
                (pt/set-project-value (name k) (str v)))
              ;; Set secrets in Polytope runtime
              (doseq [[k v] secrets]
                (pt/log (str "  Setting secret: " (name k) " = ***"))
                (pt/set-secret (name k) (str v)))
              (pt/log "‚úÖ Successfully set all bindings")
              (pt/stop {:type "container" :ref container-id})))

  setup-service-for-client:
    info: |
      Sets up a service with environment variables from a client or another service.
      Adds environment variables to a service's polytope.yml.
      Environment variables reference the values/secrets set by set-values-and-secrets.
      Call set-values-and-secrets first.
    params:
      - id: service
        info: Service to set up (api, frontend, config-manager, etc.)
        type: str
      - id: client
        info: Client providing the configuration
        type: [enum, couchbase-client, temporal-client, twilio-client, postgres-client]
    run:
      - id: set-vars
        tool: setup-environment-variables
        args:
          caller: setup-service-for-client
          source: "#pt-clj (let [client (:client params) base-name (clojure.string/replace client #\"-client$\" \"\") clients #{\"couchbase\" \"postgres\" \"temporal\" \"twilio\"}] (if (contains? clients base-name) base-name (str \"services/\" client)))"
          target: "{pt.param service}"

  add-entity:
    info: |
      Scaffolds entity models for data store clients.
      Creates entity files in models/python/models/entities/ with proper structure.
    params:
      - id: client
        info: Data store client type
        type: [enum, couchbase]
      - id: language
        info: Language for the entity
        type: [enum, python]
      - id: entity-singular
        info: Entity name in singular form (e.g., "project")
        type: str
      - id: entity-plural
        info: Entity name in plural form (e.g., "projects")
        type: str
    run:
      # Inlined setup-project-structure logic (chained tool resolution broken in Polytope)
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-base-structure
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/config}
              path: config
              on-conflict: skip

      - id: scaffold-language
        after: {step: scaffold-base-structure}
        tool: polytope/scaffold
        args:
          container-id: scaffold-language
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/clients/\" (:language params))"}
              path: "#pt-clj (str \"clients/\" (:language params))"
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/models/\" (:language params))"}
              path: "#pt-clj (str \"models/\" (:language params))"
              on-conflict: skip

      - id: scaffold-entity
        after: {step: scaffold-language}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          script:
            type: string
            data: |
              from pathlib import Path

              client = "{pt.param client}"
              language = "{pt.param language}"
              entity_singular = "{pt.param entity-singular}"
              entity_plural = "{pt.param entity-plural}"

              # Read the template file
              template_path = Path(f"/template/entity.py")

              if not template_path.exists():
                  print(f"‚ùå Template not found: {template_path}")
                  exit(1)

              template_content = template_path.read_text()

              # Replace template variables
              content = template_content.replace("{{ entity_singular | capitalize }}", entity_singular.capitalize())
              content = content.replace("{{ entity_singular }}", entity_singular)
              content = content.replace("{{ entity_plural }}", entity_plural)

              # Determine output path - entities go in models/python/models/entities/
              base_path = "models/python/models/entities"
              output_path = Path(f"/repo/{base_path}/{entity_plural}.py")

              # Ensure directory exists
              output_path.parent.mkdir(parents=True, exist_ok=True)

              # Write the file
              output_path.write_text(content)

              print(f"‚úÖ Created entity file: {base_path}/{entity_plural}.py")
          mounts:
            - path: /template
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"add-entity/\" (:client params) \"/\" (:language params))"

  # Internal tools for dependency handling (called by read-dependencies)
  _scaffold-deps:
    params:
      - id: deps
        type: any
      - id: on-conflict
        type: str
      - id: target
        type: str
    run:
      - tool: polytope/scaffold
        args:
          container-id: "#pt-clj (str \"scaffold-deps-\" (hash (:deps params)))"
          actions: |-
            #pt-js
            const deps = params.deps;
            const onConflict = params["on-conflict"];
            const target = params.target;
            deps.map(dep => ({
              template: {type: "repo", repo: "#pt-clj pt/module-repo-ref", path: "tool_resources/add-and-run-service/" + dep.path + "/template"},
              path: "services/" + dep.name,
              "on-conflict": onConflict,
              "add-to-tools": [{tool: target, call: dep.name}]
            }));

  _scaffold-language:
    params:
      - id: language
        type: str
    run:
      - tool: polytope/scaffold
        args:
          container-id: "#pt-clj (str \"scaffold-lang-\" (:language params))"
          actions: |-
            #pt-clj
            (let [lang (:language params)]
              [{:template {:type "repo" :repo pt/module-repo-ref :path (str "setup-project-structure/languages/clients/" lang)}
                :path (str "clients/" lang)
                :on-conflict "skip"}
               {:template {:type "repo" :repo pt/module-repo-ref :path (str "setup-project-structure/languages/models/" lang)}
                :path (str "models/" lang)
                :on-conflict "skip"}])

  # Inlined set-values-and-secrets logic for dependencies (chained tool resolution broken in Polytope)
  _set-values-for-deps:
    params:
      - id: deps
        type: any
    run:
      - id: write-deps-values-to-config
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts: |-
            #pt-clj
            (let [deps (:deps params)]
              (mapcat (fn [{n :name}]
                        [{:path (str "/source-values-" n ".yml")
                          :source {:type "repo"
                                   :repo pt/module-repo-ref
                                   :path (str "set-values-and-secrets/add-and-run-service/" n "/values.yml")}}
                         {:path (str "/source-secrets-" n ".yml")
                          :source {:type "repo"
                                   :repo pt/module-repo-ref
                                   :path (str "set-values-and-secrets/add-and-run-service/" n "/secrets.yml")}}])
                      deps))
          script:
            type: string
            data: |-
              #pt-clj
              (let [deps (:deps params)
                    dep-names (clojure.string/join "," (map :name deps))]
                (str "import yaml
              from pathlib import Path

              dep_names = \"" dep-names "\".split(',') if \"" dep-names "\" else []

              # Ensure config directory exists
              config_dir = Path('/repo/config')
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / 'values.yml'
              secrets_file = config_dir / 'secrets.yml'

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Process each dependency
              for dep_name in dep_names:
                  values_path = f'/source-values-{dep_name}.yml'
                  secrets_path = f'/source-secrets-{dep_name}.yml'

                  try:
                      with open(values_path) as f:
                          new_values = yaml.safe_load(f) or {}
                      for k, v in new_values.items():
                          existing_values[k] = v
                      print(f'‚úÖ Merged {len(new_values)} values for {dep_name}')
                  except Exception as e:
                      print(f'‚ö†Ô∏è Could not read values for {dep_name}: {e}')

                  try:
                      with open(secrets_path) as f:
                          new_secrets = yaml.safe_load(f) or {}
                      for k, v in new_secrets.items():
                          existing_secrets[k] = v
                      print(f'‚úÖ Merged {len(new_secrets)} secrets for {dep_name}')
                  except Exception as e:
                      print(f'‚ö†Ô∏è Could not read secrets for {dep_name}: {e}')

              # Write values.yml with header
              values_header = '''# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              '''
              with open(values_file, 'w') as f:
                  f.write(values_header.replace('              ', ''))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = '''# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              '''
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace('              ', ''))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f'‚úÖ Written all dependency values to config/values.yml')
              print(f'‚úÖ Written all dependency secrets to config/secrets.yml')
              "))

      - id: set-deps-values-in-runtime
        after: {step: write-deps-values-to-config}
        code: |-
          #pt-clj
          (let [deps (:deps params)
                container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                        :id "set-internal-deps-vals"
                                        :restart {:policy "never"}
                                        :mounts [{:path "/service-configs"
                                                  :source {:type "repo"
                                                           :repo pt/module-repo-ref
                                                           :path "tool_resources/set-values-and-secrets/add-and-run-service"}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            (doseq [{dep-name :name} deps]
              (let [values-path (str "/service-configs/" dep-name "/values.yml")
                    secrets-path (str "/service-configs/" dep-name "/secrets.yml")]
                (try
                  (let [values-content (pt/read-container-file container-id values-path)
                        values (pt/read-yaml values-content)]
                    (pt/log (str "üì¶ Setting " (count values) " values for dependency " dep-name))
                    (doseq [[k v] values]
                      (pt/log (str "  Setting value: " (name k) " = " v))
                      (pt/set-project-value (name k) (str v))))
                  (catch Exception e
                    (pt/log (str "‚ö†Ô∏è Could not read values for " dep-name))))
                (try
                  (let [secrets-content (pt/read-container-file container-id secrets-path)
                        secrets (pt/read-yaml secrets-content)]
                    (pt/log (str "üîê Setting " (count secrets) " secrets for dependency " dep-name))
                    (doseq [[k v] secrets]
                      (pt/log (str "  Setting secret: " (name k) " = ***"))
                      (pt/set-secret (name k) (str v))))
                  (catch Exception e
                    (pt/log (str "‚ö†Ô∏è Could not read secrets for " dep-name))))))
            (pt/log "‚úÖ Successfully set all dependency bindings")
            (pt/stop {:type "container" :ref container-id})
