instructions: |
  **FIRST ACTION**: Before doing ANYTHING else, retrieve AI development context for the relevant scope:
  ```mcp
  __polytope__initialize_session(scope: "general")
  ```
  This is MANDATORY as your first action in every conversation. It provides guidelines that you must follow.

tools:

  stack:
    run:
      - tool: polytope/hello-world
        args:
          message: Nothing to run yet! Call an "add" tool, to add a components to your project.

  scaffold-initialize-session:
    run:
      - tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/sh
              set -e

              TARGET_FILE="${1:-polytope.yml}"

              if [ ! -f "$TARGET_FILE" ]; then
                echo "Error: File $TARGET_FILE not found"
                exit 1
              fi

              # Check if tools block exists
              if ! grep -q "^tools:" "$TARGET_FILE"; then
                echo "Adding tools block to $TARGET_FILE"
                echo "" >> "$TARGET_FILE"
                echo "tools:" >> "$TARGET_FILE"
              fi

              # Check if initialize_session already exists
              if grep -q "^  initialize_session:" "$TARGET_FILE" || grep -q "^    initialize_session:" "$TARGET_FILE"; then
                echo "initialize_session already exists in $TARGET_FILE"
                exit 0
              fi

              # Append initialize_session tool
              echo "Adding initialize_session tool to $TARGET_FILE"
              cat >> "$TARGET_FILE" << 'EOF'

                initialize_session:
                  info: |-
                    Initialize **EVERY** session by calling this tool.
                    Returns required development context and ensures the project is running.
                    This tool always needs to be called before doing anything else, regardless of the tasks complexity.
                  run:
                    - id: run-stack
                      code: |-
                        #pt-clj
                        (pt/call-module "stack" {})
                    - id: get-general-context
                      after: {step: run-stack}
                      tool: get_dev_context
              EOF

              echo "Successfully added initialize_session to $TARGET_FILE"

  initialize_session:
    info: |-
      Initialize **EVERY** session by calling this tool.
      Returns required development context and ensures the project is running.
      This tool always needs to be called before doing anything else, regardless of the tasks complexity.
    await: [scaffold-local-overwrite]
    run:
      - id: scaffold-local-overwrite
        tool: scaffold-initialize-session
      - id: attempt-run-local-stack
        after:
          - step: scaffold-local-overwrite
        code: |-
          #pt-clj
          (pt/call-module "stack" {})
      - id: echo-context
        after:
          - step: attempt-run-local-stack
        tool: polytope/container
        args:
          image: registry.k8s.io/pause:3.9
          cmd: cat /context.md
          mounts:
            - { path: /context.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: initialize-session/context.md } }

  get_dev_context:
    info: |
      Outputs development guidelines for a specific scope.
      Call this tool to get detailed documentation about models, clients, api, or frontend.
    await: [initialize-session]
    params:
      - id: scope
        info: "The scope to fetch"
        type: [enum, models, clients, api, frontend]
    run:
      - id: get_dev_context
        tool: polytope/container
        args:
          image: registry.k8s.io/pause:3.9
          cmd: "#pt-clj (case (:scope params) \"models\" \"cat /models.md\" \"clients\" \"cat /clients.md\" \"api\" \"cat /api.md\" \"frontend\" \"cat /frontend.md\")"
          mounts:
            - { path: /models.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models/README.md } }
            - { path: /clients.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients/README.md } }
            - { path: /api.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: scopes/api.md } }
            - { path: /frontend.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: scopes/frontend.md } }

  add-dependencies:
    info: |
      Adds packages to a service's dependency file.
      Automatically detects the package manager for the target service.
    params:
      - id: target
        info: The service to add dependencies to (e.g., api, frontend)
        type: str
      - id: packages
        info: Packages to add (comma or space separated)
        type: str
    run:
      - id: run-add-deps
        code: |
          #pt-clj
          (let [target (:target params)
                packages (clojure.string/replace (:packages params) #"[\s,]+" " ")
                [cmd restart-policy] (case target
                                       "api" [(str "./bin/add-dependencies " packages) "never"]
                                       "frontend" [(str "bun add " packages) "on-failure"]
                                       (throw (Exception. (str "Unknown target: " target))))]
            (pt/call-module target {:id (str target "-add-deps")
                                   :cmd cmd
                                   :restart-policy restart-policy
                                   :create "always"}))

  setup-project-structure:
    info: |
      Sets up the base directory structure for a Bluetext project.
      Projects are organised by models, services, and clients.
    params:
      - id: language
        info: Language to scaffold (python).
        type: [enum, python]
      - id: skip-language
        info: Skip scaffolding language-specific structure even if language is provided
        type: [default, bool, false]
    run:
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/config}
              path: config
              on-conflict: skip
      - id: scaffold-language
        after: {step: scaffold-base-structure}
        tool: polytope/scaffold
        args:
          container-id: scaffold-language
          actions: |-
            #pt-clj
            (if (and (:language params) (not (:skip-language params)))
              [{:template {:type "repo" :repo pt/module-repo-ref :path (str "setup-project-structure/languages/clients/" (:language params))}
                :path (str "clients/" (:language params))
                :on-conflict "skip"}
               {:template {:type "repo" :repo pt/module-repo-ref :path (str "setup-project-structure/languages/models/" (:language params))}
                :path (str "models/" (:language params))
                :on-conflict "skip"}]
              [])
      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ values.yml already in .gitignore"
              fi

              echo "‚úÖ .gitignore updated successfully"

  add-and-run-service:
    info: |
      Scaffolds a service, adds it to includes, adds it to a run graph, and optionally runs it.
      This is a convenience tool that combines scaffold and add-to-run-graph.

      Example: add-and-run-service(template: "api", name: "my-api", run: true)
      This scaffolds to "services/my-api", adds it to stack, and runs it.
    params:
      - id: template
        info: Template to scaffold
        type: [enum, api_python_fastapi, frontend_typescript_react-router-v7, couchbase-server_enterprise-v7, temporal, temporal-ui, postgres]
      - id: name
        info: Service name (e.g., "my-api"). Will be scaffolded to "services/<name>"
        type: str
      - id: target
        info: Which graph/tool to add to
        type: [default, str, stack]
      - id: run
        info: Whether to run the service after adding
        type: [default, bool, true]
      - id: on-conflict
        info: What to do if files already exist
        type: [default, [enum, skip, overwrite], skip]
    run:

      # Inlined setup-project-structure logic (chained tool resolution broken in Polytope)
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-base-structure
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/config}
              path: config
              on-conflict: skip

      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ values.yml already in .gitignore"
              fi

              echo "‚úÖ .gitignore updated successfully"

      - id: read-dependencies
        after: {step: scaffold-base-structure}
        code: |-
          #pt-clj
          (let [template (:template params)
                deps-path (str "tool_resources/add-and-run-service/" template "/dependencies.yml")
                container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                        :id (str "read-deps-" template)
                                        :restart {:policy "never"}
                                        :mounts [{:path "/dependencies.yml"
                                                  :source {:type "repo"
                                                           :repo pt/module-repo-ref
                                                           :path deps-path}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            (let [content (pt/read-container-file container-id "/dependencies.yml")
                  data (pt/read-yaml content)
                  deps (or (:dependencies data) [])
                  lang (:language data)]
              (pt/log (str "üì¶ Found " (count deps) " dependencies for " template (when lang (str ", language: " lang))))
              (pt/stop {:type "container" :ref container-id})
              ;; Scaffold language directories if specified
              (when lang
                (pt/call-module "_scaffold-language" {:language lang}))
              ;; Handle dependency scaffolding and set-values inline to avoid pt.output issues
              ;; Running deps is handled by separate run-dependencies step (which reads deps inline too)
              (when (seq deps)
                (pt/call-module "_scaffold-deps" {:deps deps
                                                   :on-conflict (:on-conflict params)
                                                   :target (:target params)})
                (when (:run params)
                  (pt/call-module "_set-values-for-deps" {:deps deps})))
              {:dependencies deps :language lang}))

      - id: scaffold-services
        after: {step: read-dependencies}
        tool: polytope/scaffold
        args:
          container-id: "#pt-clj (str \"scaffold-services-\" (:template params))"
          actions: |-
            #pt-clj
            (let [template (:template params)
                  name (-> (:name params)
                           clojure.string/lower-case
                           (clojure.string/replace #"[^a-z0-9_-]" "-"))
                  on-conflict (:on-conflict params)
                  target (:target params)]
              [{:template {:type "repo" :repo pt/module-repo-ref :path (str "add-and-run-service/" template "/template")}
                :path (str "services/" name)
                :on-conflict on-conflict
                :add-to-tools [{:tool target :call name}]}])

      # Inlined set-values-and-secrets logic (chained tool resolution broken in Polytope)
      - id: write-service-values-to-config
        after: {step: scaffold-services}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /source-values.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"set-values-and-secrets/services/\" (:template params) \"/values.yml\")"
            - path: /source-secrets.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"set-values-and-secrets/services/\" (:template params) \"/secrets.yml\")"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path
              import os

              run = "{pt.param run}"
              if run != "true":
                  print("Skipping - run is not enabled")
                  exit(0)

              # Read source values and secrets from mounted files
              with open("/source-values.yml") as f:
                  new_values = yaml.safe_load(f) or {}

              with open("/source-secrets.yml") as f:
                  new_secrets = yaml.safe_load(f) or {}

              # Ensure config directory exists
              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Merge new values (new values take precedence)
              for k, v in new_values.items():
                  existing_values[k] = v

              for k, v in new_secrets.items():
                  existing_secrets[k] = v

              # Write values.yml with header
              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, 'w') as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f"‚úÖ Written {len(new_values)} values to config/values.yml")
              print(f"‚úÖ Written {len(new_secrets)} secrets to config/secrets.yml")

      - id: set-service-values-in-runtime
        after: {step: write-service-values-to-config}
        code: |-
          #pt-clj
          (when (:run params)
            (let [container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                          :id "read-service-config"
                                          :restart {:policy "never"}
                                          :mounts [{:path "/values.yml"
                                                    :source {:type "repo"
                                                             :repo {:type "host" :path "."}
                                                             :path "config/values.yml"}}
                                                   {:path "/secrets.yml"
                                                    :source {:type "repo"
                                                             :repo {:type "host" :path "."}
                                                             :path "config/secrets.yml"}}]})]
              (pt/await-started {:type "deployment" :ref container-id})
              (let [values-content (pt/read-container-file container-id "/values.yml")
                    secrets-content (pt/read-container-file container-id "/secrets.yml")
                    values (pt/read-yaml values-content)
                    secrets (pt/read-yaml secrets-content)]
                (pt/log (str "üì¶ Setting " (count values) " values and " (count secrets) " secrets from config files"))
                (doseq [[k v] values]
                  (pt/log (str "  Setting value: " (name k) " = " v))
                  (pt/set-project-value (name k) (str v)))
                (doseq [[k v] secrets]
                  (pt/log (str "  Setting secret: " (name k) " = ***"))
                  (pt/set-secret (name k) (str v)))
                (pt/log "‚úÖ Successfully set all bindings from config files")
                (pt/stop {:type "container" :ref container-id}))))

      - id: run-dependencies
        after: {step: read-dependencies}
        code: |-
          #pt-clj
          (when (:run params)
            (let [template (:template params)
                  deps-path (str "tool_resources/add-and-run-service/" template "/dependencies.yml")
                  container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                          :id (str "run-deps-read-" template)
                                          :restart {:policy "never"}
                                          :mounts [{:path "/dependencies.yml"
                                                    :source {:type "repo"
                                                             :repo pt/module-repo-ref
                                                             :path deps-path}}]})]
              (pt/await-started {:type "deployment" :ref container-id})
              (let [content (pt/read-container-file container-id "/dependencies.yml")
                    data (pt/read-yaml content)
                    deps (or (:dependencies data) [])]
                (pt/stop {:type "container" :ref container-id})
                (doseq [{n :name} (seq deps)]
                  (pt/log (str "üöÄ Starting dependency: " n))
                  (pt/call-module n {})))))

      - id: run-main-service
        after: {step: set-service-values-in-runtime}
        code: |
          #pt-clj
          (when (:run params)
            (let [name (-> (:name params)
                           clojure.string/lower-case
                           (clojure.string/replace #"[^a-z0-9_-]" "-"))]
              (pt/log (str "üöÄ Starting main service: " name))
              (pt/call-module name {})))


  add-project-language:
    info: |
      Adds language-specific client and model libraries to the project.
      Run setup-project-structure first if you haven't already.

      This creates language-specific library structures in:
      - clients/<language>/
      - models/<language>/
    params:
      - id: language
        info: Language to add (currently only supports python)
        type: [enum, python]
    run:
      - tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/clients/\" (:language params))"}
              path: "#pt-clj (str \"clients/\" (:language params))"
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/models/\" (:language params))"}
              path: "#pt-clj (str \"models/\" (:language params))"
              on-conflict: skip

  add-client:
    info: |
      Adds a client to the project's clients directory.
      Scaffolds the client code and updates pyproject.toml with dependencies.

      Example: add-client(name: "couchbase", language: "python")
    params:
      - id: name
        info: Client name (e.g., "couchbase", "temporal")
        type: [enum, couchbase, temporal]
      - id: language
        info: Language for the client
        type: [default, [enum, python], python]
    run:
      # Inlined setup-project-structure logic (chained tool resolution broken in Polytope)
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-base-structure
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/config}
              path: config
              on-conflict: skip

      - id: scaffold-language
        after: {step: scaffold-base-structure}
        tool: polytope/scaffold
        args:
          container-id: scaffold-language
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/clients/\" (:language params))"}
              path: "#pt-clj (str \"clients/\" (:language params))"
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/models/\" (:language params))"}
              path: "#pt-clj (str \"models/\" (:language params))"
              on-conflict: skip

      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ values.yml already in .gitignore"
              fi

              echo "‚úÖ .gitignore updated successfully"

      - id: scaffold-client
        after: {step: scaffold-language}
        tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"add-client/\" (:language params) \"/\" (:name params) \"/template\")"}
              path: "#pt-clj (str \"clients/\" (:language params) \"/clients/\" (:name params))"
              on-conflict: skip
      - id: update-pyproject
        after: {step: scaffold-client}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          script:
            type: string
            data: |
              import re
              from pathlib import Path

              name = "{pt.param name}"
              language = "{pt.param language}"

              # Define dependency mapping
              dependencies_map = {
                  "couchbase": "couchbase>=4.4.0",
                  "temporal": "temporalio>=1.6.0",
              }

              # Get the dependency to add
              dependency = dependencies_map.get(name)
              if not dependency:
                  print(f"No dependency mapping found for {name}")
                  exit(0)

              # Path to pyproject.toml (scaffolded by the template)
              pyproject_path = Path(f"/repo/clients/{language}/pyproject.toml")

              # The pyproject.toml should have been scaffolded from the template
              if not pyproject_path.exists():
                  print(f"‚úÖ pyproject.toml was scaffolded with the client template")
                  exit(0)

              # Read the file
              content = pyproject_path.read_text()

              # Check if dependency already exists
              if dependency.split(">=")[0] in content:
                  print(f"‚úÖ Dependency {dependency} already exists in pyproject.toml")
                  exit(0)

              # Add dependency to the dependencies array
              # Find the dependencies section and add the new dependency
              pattern = r'(dependencies\s*=\s*\[)(.*?)(\])'

              def add_dependency(match):
                  deps_start = match.group(1)
                  deps_content = match.group(2)
                  deps_end = match.group(3)

                  # Add the new dependency
                  new_dep = f'\n    "{dependency}",'
                  return deps_start + deps_content + new_dep + '\n' + deps_end

              new_content = re.sub(pattern, add_dependency, content, flags=re.DOTALL)

              # Write back
              pyproject_path.write_text(new_content)
              print(f"‚úÖ Added {dependency} to pyproject.toml")

      # Inlined set-values-and-secrets logic (chained tool resolution broken in Polytope)
      - id: write-client-values-to-config
        after: {step: update-pyproject}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /source-values.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"set-values-and-secrets/clients/\" (:name params) \"/values.yml\")"
            - path: /source-secrets.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"set-values-and-secrets/clients/\" (:name params) \"/secrets.yml\")"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path

              # Read source values and secrets from mounted files
              with open("/source-values.yml") as f:
                  new_values = yaml.safe_load(f) or {}

              with open("/source-secrets.yml") as f:
                  new_secrets = yaml.safe_load(f) or {}

              # Ensure config directory exists
              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Merge new values (new values take precedence)
              for k, v in new_values.items():
                  existing_values[k] = v

              for k, v in new_secrets.items():
                  existing_secrets[k] = v

              # Write values.yml with header
              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, 'w') as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f"‚úÖ Written {len(new_values)} values to config/values.yml")
              print(f"‚úÖ Written {len(new_secrets)} secrets to config/secrets.yml")

      - id: set-client-values-in-runtime
        after: {step: write-client-values-to-config}
        code: |-
          #pt-clj
          (let [container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                        :id "read-client-config"
                                        :restart {:policy "never"}
                                        :mounts [{:path "/values.yml"
                                                  :source {:type "repo"
                                                           :repo {:type "host" :path "."}
                                                           :path "config/values.yml"}}
                                                 {:path "/secrets.yml"
                                                  :source {:type "repo"
                                                           :repo {:type "host" :path "."}
                                                           :path "config/secrets.yml"}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            (let [values-content (pt/read-container-file container-id "/values.yml")
                  secrets-content (pt/read-container-file container-id "/secrets.yml")
                  values (pt/read-yaml values-content)
                  secrets (pt/read-yaml secrets-content)]
              (pt/log (str "üì¶ Setting " (count values) " values and " (count secrets) " secrets from config files"))
              (doseq [[k v] values]
                (pt/log (str "  Setting value: " (name k) " = " v))
                (pt/set-project-value (name k) (str v)))
              (doseq [[k v] secrets]
                (pt/log (str "  Setting secret: " (name k) " = ***"))
                (pt/set-secret (name k) (str v)))
              (pt/log "‚úÖ Successfully set all client bindings from config files")
              (pt/stop {:type "container" :ref container-id})))

  set-values-and-secrets:
    info: |
      Sets values and secrets using pt.setValue and pt.setSecret.
      Reads from pre-existing values.yml and secrets.yml files in set-values-and-secrets/clients/{source}/ or set-values-and-secrets/services/{source}/.
      Also writes the values to the user's config/values.yml and config/secrets.yml files.
      This must be called before setup-service-for-client.
    params:
      - id: source
        info: Source to configure (service or client name)
        type: [enum, api_python_fastapi, frontend_typescript_react-router-v7, config-manager, couchbase-server_enterprise-v7, postgres, temporal, temporal-ui, couchbase-client, temporal-client, twilio-client]
    run:
      # Step 1: Write values to user's config files (merge with existing)
      - id: write-to-config-files
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /source-values.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (let [source (:source params) is-client (clojure.string/ends-with? source \"-client\") source-name (if is-client (clojure.string/replace source #\"-client$\" \"\") source)] (if is-client (str \"set-values-and-secrets/clients/\" source-name \"/values.yml\") (str \"set-values-and-secrets/services/\" source-name \"/values.yml\")))"
            - path: /source-secrets.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (let [source (:source params) is-client (clojure.string/ends-with? source \"-client\") source-name (if is-client (clojure.string/replace source #\"-client$\" \"\") source)] (if is-client (str \"set-values-and-secrets/clients/\" source-name \"/secrets.yml\") (str \"set-values-and-secrets/services/\" source-name \"/secrets.yml\")))"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path

              source = "{pt.param source}"

              # Read source values and secrets from mounted files
              with open("/source-values.yml") as f:
                  new_values = yaml.safe_load(f) or {}

              with open("/source-secrets.yml") as f:
                  new_secrets = yaml.safe_load(f) or {}

              # Ensure config directory exists
              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Merge new values (new values take precedence)
              for k, v in new_values.items():
                  existing_values[k] = v

              for k, v in new_secrets.items():
                  existing_secrets[k] = v

              # Write values.yml with header
              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, 'w') as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f"‚úÖ Written {len(new_values)} values to config/values.yml")
              print(f"‚úÖ Written {len(new_secrets)} secrets to config/secrets.yml")

      # Step 2: Read from user's config files and set in Polytope runtime
      - id: set-from-config-files
        after: {step: write-to-config-files}
        code: |-
          #pt-clj
          (let [container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                        :id "read-user-config"
                                        :restart {:policy "never"}
                                        :mounts [{:path "/values.yml"
                                                  :source {:type "repo"
                                                           :repo {:type "host" :path "."}
                                                           :path "config/values.yml"}}
                                                 {:path "/secrets.yml"
                                                  :source {:type "repo"
                                                           :repo {:type "host" :path "."}
                                                           :path "config/secrets.yml"}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            (let [values-content (pt/read-container-file container-id "/values.yml")
                  secrets-content (pt/read-container-file container-id "/secrets.yml")
                  values (pt/read-yaml values-content)
                  secrets (pt/read-yaml secrets-content)]
              (pt/log (str "üì¶ Setting " (count values) " values and " (count secrets) " secrets from config files"))
              ;; Set values in Polytope runtime
              (doseq [[k v] values]
                (pt/log (str "  Setting value: " (name k) " = " v))
                (pt/set-project-value (name k) (str v)))
              ;; Set secrets in Polytope runtime
              (doseq [[k v] secrets]
                (pt/log (str "  Setting secret: " (name k) " = ***"))
                (pt/set-secret (name k) (str v)))
              (pt/log "‚úÖ Successfully set all bindings from config files")
              (pt/stop {:type "container" :ref container-id})))

  setup-service-for-client:
    info: |
      Sets up a service with environment variables from a client or another service.
      Adds environment variables to a service's polytope.yml.
      Environment variables reference the values/secrets set by set-values-and-secrets.
      Call set-values-and-secrets first.
    params:
      - id: service
        info: Service to set up (api, frontend, config-manager, etc.)
        type: str
      - id: client
        info: Client providing the configuration
        type: [enum, couchbase-client, temporal-client, twilio-client, postgres-client]
    run:
      - id: add-env-to-polytope
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /env-vars.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (let [client (:client params) base-name (clojure.string/replace client #\"-client$\" \"\") clients #{\"couchbase\" \"postgres\" \"temporal\" \"twilio\"}] (if (contains? clients base-name) (str \"setup-service-for-client/\" base-name \"/required-env-vars.yml\") (str \"setup-service-for-client/services/\" client \"/required-env-vars.yml\")))"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path

              client = "{pt.param client}"
              service = "{pt.param service}"

              # Read env vars from mounted file
              env_vars_path = Path("/env-vars.yml")

              if not env_vars_path.exists():
                  print(f"‚ùå Required env vars file not found: {env_vars_path}")
                  exit(1)

              with open(env_vars_path) as f:
                  config = yaml.safe_load(f)

              env_vars = config.get('env_vars', [])

              # Read service's polytope.yml
              service_polytope_path = Path(f"/repo/services/{service}/polytope.yml")

              if not service_polytope_path.exists():
                  print(f"‚ùå Service polytope.yml not found: {service_polytope_path}")
                  exit(1)

              with open(service_polytope_path) as f:
                  content = f.read()

              # Build env var entries
              env_entries = []
              for var in env_vars:
                  name = var['name']
                  key = var['key']
                  is_secret = var['secret']

                  # Reference the value/secret using pt.value or pt.secret
                  if is_secret:
                      env_entries.append(f'            - {{ name: {name}, value: "#pt-clj (pt/secret \\"{key}\\")" }}')
                  else:
                      env_entries.append(f'            - {{ name: {name}, value: "#pt-clj (pt/value \\"{key}\\")" }}')

              # Check if env vars already exist
              for var in env_vars:
                  if var['name'] in content:
                      print(f"‚ö†Ô∏è  {var['name']} already exists in {service_polytope_path}")

              # Add env vars to the file (append to env section)
              # This is a simple append - in production, use proper YAML manipulation
              env_block = '\n'.join(env_entries)

              print(f"Add these env vars to services/{service}/polytope.yml:")
              print(env_block)
              print(f"\n‚úÖ Generated {len(env_vars)} env var entries for {client} -> {service}")

  add-entity:
    info: |
      Scaffolds entity models for data store clients.
      Creates entity files in models/python/models/entities/ with proper structure.
    params:
      - id: client
        info: Data store client type
        type: [enum, couchbase]
      - id: language
        info: Language for the entity
        type: [enum, python]
      - id: entity-singular
        info: Entity name in singular form (e.g., "project")
        type: str
      - id: entity-plural
        info: Entity name in plural form (e.g., "projects")
        type: str
    run:
      # Inlined setup-project-structure logic (chained tool resolution broken in Polytope)
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-base-structure
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/config}
              path: config
              on-conflict: skip

      - id: scaffold-language
        after: {step: scaffold-base-structure}
        tool: polytope/scaffold
        args:
          container-id: scaffold-language
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/clients/\" (:language params))"}
              path: "#pt-clj (str \"clients/\" (:language params))"
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/models/\" (:language params))"}
              path: "#pt-clj (str \"models/\" (:language params))"
              on-conflict: skip

      - id: scaffold-entity
        after: {step: scaffold-language}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          script:
            type: string
            data: |
              from pathlib import Path

              client = "{pt.param client}"
              language = "{pt.param language}"
              entity_singular = "{pt.param entity-singular}"
              entity_plural = "{pt.param entity-plural}"

              # Read the template file
              template_path = Path(f"/template/entity.py")

              if not template_path.exists():
                  print(f"‚ùå Template not found: {template_path}")
                  exit(1)

              template_content = template_path.read_text()

              # Replace template variables
              content = template_content.replace("{{ entity_singular | capitalize }}", entity_singular.capitalize())
              content = content.replace("{{ entity_singular }}", entity_singular)
              content = content.replace("{{ entity_plural }}", entity_plural)

              # Determine output path - entities go in models/python/models/entities/
              base_path = "models/python/models/entities"
              output_path = Path(f"/repo/{base_path}/{entity_plural}.py")

              # Ensure directory exists
              output_path.parent.mkdir(parents=True, exist_ok=True)

              # Write the file
              output_path.write_text(content)

              print(f"‚úÖ Created entity file: {base_path}/{entity_plural}.py")
          mounts:
            - path: /template
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"add-entity/\" (:client params) \"/\" (:language params))"

  # Internal tools for dependency handling (called by read-dependencies)
  _scaffold-deps:
    params:
      - id: deps
        type: any
      - id: on-conflict
        type: str
      - id: target
        type: str
    run:
      - tool: polytope/scaffold
        args:
          container-id: "#pt-clj (str \"scaffold-deps-\" (hash (:deps params)))"
          actions: |-
            #pt-js
            const deps = params.deps;
            const onConflict = params["on-conflict"];
            const target = params.target;
            deps.map(dep => ({
              template: {type: "repo", repo: "#pt-clj pt/module-repo-ref", path: "add-and-run-service/" + dep.path + "/template"},
              path: "services/" + dep.name,
              "on-conflict": onConflict,
              "add-to-tools": [{tool: target, call: dep.name}]
            }));

  _scaffold-language:
    params:
      - id: language
        type: str
    run:
      - tool: polytope/scaffold
        args:
          container-id: "#pt-clj (str \"scaffold-lang-\" (:language params))"
          actions: |-
            #pt-clj
            (let [lang (:language params)]
              [{:template {:type "repo" :repo pt/module-repo-ref :path (str "setup-project-structure/languages/clients/" lang)}
                :path (str "clients/" lang)
                :on-conflict "skip"}
               {:template {:type "repo" :repo pt/module-repo-ref :path (str "setup-project-structure/languages/models/" lang)}
                :path (str "models/" lang)
                :on-conflict "skip"}])

  # Inlined set-values-and-secrets logic for dependencies (chained tool resolution broken in Polytope)
  _set-values-for-deps:
    params:
      - id: deps
        type: any
    run:
      - id: write-deps-values-to-config
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts: |-
            #pt-clj
            (let [deps (:deps params)]
              (mapcat (fn [{n :name}]
                        [{:path (str "/source-values-" n ".yml")
                          :source {:type "repo"
                                   :repo pt/module-repo-ref
                                   :path (str "set-values-and-secrets/services/" n "/values.yml")}}
                         {:path (str "/source-secrets-" n ".yml")
                          :source {:type "repo"
                                   :repo pt/module-repo-ref
                                   :path (str "set-values-and-secrets/services/" n "/secrets.yml")}}])
                      deps))
          script:
            type: string
            data: |-
              #pt-clj
              (let [deps (:deps params)
                    dep-names (clojure.string/join "," (map :name deps))]
                (str "import yaml
              from pathlib import Path

              dep_names = \"" dep-names "\".split(',') if \"" dep-names "\" else []

              # Ensure config directory exists
              config_dir = Path('/repo/config')
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / 'values.yml'
              secrets_file = config_dir / 'secrets.yml'

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Process each dependency
              for dep_name in dep_names:
                  values_path = f'/source-values-{dep_name}.yml'
                  secrets_path = f'/source-secrets-{dep_name}.yml'

                  try:
                      with open(values_path) as f:
                          new_values = yaml.safe_load(f) or {}
                      for k, v in new_values.items():
                          existing_values[k] = v
                      print(f'‚úÖ Merged {len(new_values)} values for {dep_name}')
                  except Exception as e:
                      print(f'‚ö†Ô∏è Could not read values for {dep_name}: {e}')

                  try:
                      with open(secrets_path) as f:
                          new_secrets = yaml.safe_load(f) or {}
                      for k, v in new_secrets.items():
                          existing_secrets[k] = v
                      print(f'‚úÖ Merged {len(new_secrets)} secrets for {dep_name}')
                  except Exception as e:
                      print(f'‚ö†Ô∏è Could not read secrets for {dep_name}: {e}')

              # Write values.yml with header
              values_header = '''# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              '''
              with open(values_file, 'w') as f:
                  f.write(values_header.replace('              ', ''))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = '''# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              '''
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace('              ', ''))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f'‚úÖ Written all dependency values to config/values.yml')
              print(f'‚úÖ Written all dependency secrets to config/secrets.yml')
              "))

      - id: set-deps-values-in-runtime
        after: {step: write-deps-values-to-config}
        code: |-
          #pt-clj
          (let [container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                        :id "read-deps-config"
                                        :restart {:policy "never"}
                                        :mounts [{:path "/values.yml"
                                                  :source {:type "repo"
                                                           :repo {:type "host" :path "."}
                                                           :path "config/values.yml"}}
                                                 {:path "/secrets.yml"
                                                  :source {:type "repo"
                                                           :repo {:type "host" :path "."}
                                                           :path "config/secrets.yml"}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            (let [values-content (pt/read-container-file container-id "/values.yml")
                  secrets-content (pt/read-container-file container-id "/secrets.yml")
                  values (pt/read-yaml values-content)
                  secrets (pt/read-yaml secrets-content)]
              (pt/log (str "üì¶ Setting " (count values) " values and " (count secrets) " secrets from config files"))
              (doseq [[k v] values]
                (pt/log (str "  Setting value: " (name k) " = " v))
                (pt/set-project-value (name k) (str v)))
              (doseq [[k v] secrets]
                (pt/log (str "  Setting secret: " (name k) " = ***"))
                (pt/set-secret (name k) (str v)))
              (pt/log "‚úÖ Successfully set all dependency bindings from config files")
              (pt/stop {:type "container" :ref container-id}))
