instructions: |
  **FIRST ACTION**: Before doing ANYTHING else, retrieve AI development context for the relevant scope:
  ```mcp
  __polytope__initialize_session()
  ```
  This is MANDATORY as your first action in every conversation. It provides guidelines that you must follow.

include:
  - implement/polytope.yml
  - setup-environment-variables/polytope.yml
  - add-and-run-service/polytope.yml
  - add-client/polytope.yml
  - add-to-managed-services/polytope.yml

tools:

  stack:
    info: |
      Loads configuration from config files and then runs all services.
      Use stack-apply-services instead if config is already loaded and you just want to (re)start services.
    run:
      - id: load-config
        tool: load-config
      - id: run-stack
        after: {step: load-config}
        tool: stack-apply-services

  stack-apply-services:
    info: |
      Runs all services without reloading configuration.
      Config must already be loaded in the Polytope context (e.g. by calling stack or load-config first).
    run:
      - tool: polytope/hello-world
        args:
          message: Nothing to run yet! Call an "add" tool, to add components to your project.

  scaffold-initialize-session:
    run:
      - tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/sh
              set -e

              TARGET_FILE="${1:-polytope.yml}"

              if [ ! -f "$TARGET_FILE" ]; then
                echo "Error: File $TARGET_FILE not found"
                exit 1
              fi

              # Check if tools block exists
              if ! grep -q "^tools:" "$TARGET_FILE"; then
                echo "Adding tools block to $TARGET_FILE"
                echo "" >> "$TARGET_FILE"
                echo "tools:" >> "$TARGET_FILE"
              fi

              # Check if initialize_session already exists
              if grep -q "^  initialize_session:" "$TARGET_FILE" || grep -q "^    initialize_session:" "$TARGET_FILE"; then
                echo "initialize_session already exists in $TARGET_FILE"
                exit 0
              fi

              # Append initialize_session tool
              echo "Adding initialize_session tool to $TARGET_FILE"
              cat >> "$TARGET_FILE" << 'EOF'

                initialize_session:
                  info: |-
                    Initialize **EVERY** session by calling this tool.
                    Returns required development context and ensures the project is running.
                    This tool always needs to be called before doing anything else, regardless of the tasks complexity.
                  run:
                    - id: get-general-context
                      tool: get_dev_context
                    - id: apply-stack-and-await-finish
                      tool: "stack"
              EOF

              echo "Successfully added initialize_session to $TARGET_FILE"

  load-config:
    info: |
      Loads configuration from config/values.yml and config/secrets.yml into the Polytope context.
      Useful for initializing the session with existing configuration.
    run:
      - id: load-values-and-secrets
        code: |-
          pt.js
          try {
            const values = pt.readYaml(pt.readRepoFile("config/values.yml")) || {};
            pt.log(`üì¶ Loading ${Object.keys(values).length} values from config/values.yml`);
            for (const [k, v] of Object.entries(values)) {
              pt.log(`  Setting value: ${k} = ${v}`);
              pt.setProjectValue(k, String(v));
            }
          } catch (e) {
            pt.log("‚ÑπÔ∏è No config/values.yml found or could not be read.");
          }

          try {
            const secrets = pt.readYaml(pt.readRepoFile("config/secrets.yml")) || {};
            pt.log(`üîê Loading ${Object.keys(secrets).length} secrets from config/secrets.yml`);
            for (const [k, v] of Object.entries(secrets)) {
              pt.log(`  Setting secret: ${k} = ***`);
              pt.setSecret(k, String(v));
            }
          } catch (e) {
            pt.log("‚ÑπÔ∏è No config/secrets.yml found or could not be read.");
          }

  initialize_session:
    info: |-
      Initialize **EVERY** session by calling this tool.
      Returns required development context and ensures the project is running.
      This tool always needs to be called before doing anything else, regardless of the tasks complexity.
    await: [return-context]
    run:
      - id: scaffold-local-overwrite
        tool: scaffold-initialize-session
      - id: attempt-run-local-stack
        after:
          - step: scaffold-local-overwrite
        tool: stack
      - id: return-context
        after:
          - step: scaffold-local-overwrite
        tool: get_dev_context
        args:
          scope: general

  get_dev_context:
    info: |
      Outputs development guidelines for a specific scope.
      Call this tool to get detailed documentation about models, clients, api, or frontend.
      If no scope is provided, returns general development context.
    inputs:
      scope:
        info: "The scope to fetch (optional, defaults to general context)"
        type: [default, [enum, general, models, clients, api, frontend], general]
    run:
      - id: get_dev_context
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          mounts:
            - { path: /general.md, source: { type: repo, path: tool_resources/initialize-session/context.md } }
            - { path: /models.md, source: { type: repo, path: tool_resources/setup-project-structure/base/models/README.md } }
            - { path: /clients.md, source: { type: repo, path: tool_resources/setup-project-structure/base/clients/README.md } }
            - { path: /api.md, source: { type: repo, path: tool_resources/scopes/api.md } }
            - { path: /frontend.md, source: { type: repo, path: tool_resources/scopes/frontend.md } }
          script:
            type: string
            data: |
              #!/bin/bash
              SCOPE="{pt.param scope}"
              case "$SCOPE" in
                models) cat /models.md ;;
                clients) cat /clients.md ;;
                api) cat /api.md ;;
                frontend) cat /frontend.md ;;
                *) cat /general.md ;;
              esac

  # add-dependencies:
  #   info: |
  #     Adds packages to a service's dependency file.
  #     Automatically detects the package manager for the target service.
  #   inputs:
  #     - id: target
  #       info: The service to add dependencies to (e.g., api, frontend)
  #       type: str
  #     - id: packages
  #       info: Packages to add (comma or space separated)
  #       type: str
  #   run:
  #     - id: run-add-deps
  #       code: |
  #         pt.clj
  #         (let [target (:target inputs)
  #               packages (clojure.string/replace (:packages inputs) #"[\s,]+" " ")
  #               [cmd restart-policy] (case target
  #                                      "api" [(str "./bin/add-dependencies " packages) "never"]
  #                                      "frontend" [(str "bun add " packages) "on-failure"]
  #                                      (throw (Exception. (str "Unknown target: " target))))]
  #           (pt/call-module target {:id (str target "-add-deps")
  #                                  :cmd cmd
  #                                  :restart-policy restart-policy
  #                                  :create "always"}))

  setup-project-structure:
    info: |
      Sets up the base directory structure for a Bluetext project.
      Projects are organised by models, services, and clients.
    inputs:
      language:
        info: Language to scaffold (python).
        type: [enum, python]
      skip-language:
        info: Skip scaffolding language-specific structure even if language is provided
        type: [default, bool, false]
    run:
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template:
                type: repo
                repo: pt.js pt.moduleRepoRef
                path: tool_resources/setup-project-structure/base/clients
              path: clients
              on-conflict: skip
            - template:
                type: repo
                repo: pt.js pt.moduleRepoRef
                path: tool_resources/setup-project-structure/base/models
              path: models
              on-conflict: skip
            - template:
                type: repo
                repo: pt.js pt.moduleRepoRef
                path: tool_resources/setup-project-structure/base/services
              path: services
              on-conflict: skip
            - template:
                type: repo
                repo: pt.js pt.moduleRepoRef
                path: tool_resources/setup-project-structure/base/config
              path: config
              on-conflict: skip
      - id: scaffold-language
        after: {step: scaffold-base-structure}
        tool: polytope/scaffold
        args:
          container-id: scaffold-language
          actions: |-
            pt.clj
            (if (and (:language inputs) (not (:skip-language inputs)))
              [{:template {:type "repo" :repo pt/module-repo-ref :path (str "tool_resources/setup-project-structure/languages/clients/" (:language inputs))}
                :path (str "clients/" (:language inputs))
                :on-conflict "skip"}
               {:template {:type "repo" :repo pt/module-repo-ref :path (str "tool_resources/setup-project-structure/languages/models/" (:language inputs))}
                :path (str "models/" (:language inputs))
                :on-conflict "skip"}]
              [])
      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ values.yml already in .gitignore"
              fi

              echo "‚úÖ .gitignore updated successfully"




  add-project-language:
    info: |
      Adds language-specific client and model libraries to the project.
      Run setup-project-structure first if you haven't already.

      This creates language-specific library structures in:
      - clients/<language>/
      - models/<language>/
    inputs:
      language:
        info: Language to add (currently only supports python)
        type: [enum, python]
    run:
      - tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template:
                type: repo
                repo: pt.js pt.moduleRepoRef
                path: pt.js `setup-project-structure/languages/clients/${inputs.language}`
              path: pt.js `clients/${inputs.language}`
              on-conflict: skip
            - template:
                type: repo
                repo: pt.js pt.moduleRepoRef
                path: pt.js `setup-project-structure/languages/models/${inputs.language}`
              path: pt.js `models/${inputs.language}`
              on-conflict: skip

  # add-client has been moved to tool_resources/add-client/polytope.yml

  set-values-and-secrets:
    info: |
      Sets values and secrets using pt.setValue and pt.setSecret.
      Reads from pre-existing values.yml and secrets.yml files in set-values-and-secrets/add-client/{source}/ or set-values-and-secrets/add-and-run-service/{source}/.
      Also writes the values to the user's config/values.yml and config/secrets.yml files.
      This must be called before setup-service-for-client.
    inputs:
      source:
        info: Source to configure (service, client name, or implement path)
        type: str
    run:
      # Step 1: Write values to user's config files (merge with existing)
      - id: write-to-config-files
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /source-values.yml
              source:
                type: repo
                repo: "pt.clj pt/module-repo-ref"
                path: "pt.clj (let [source (:source inputs)] (cond (clojure.string/starts-with? source \"implement/\") (str \"tool_resources/set-values-and-secrets/\" source \"/values.yml\") (clojure.string/ends-with? source \"-client\") (str \"tool_resources/set-values-and-secrets/add-client/\" (clojure.string/replace source #\"-client$\" \"\") \"/values.yml\") :else (str \"tool_resources/set-values-and-secrets/add-and-run-service/\" source \"/values.yml\")))"
            - path: /source-secrets.yml
              source:
                type: repo
                repo: "pt.clj pt/module-repo-ref"
                path: "pt.clj (let [source (:source inputs)] (cond (clojure.string/starts-with? source \"implement/\") (str \"tool_resources/set-values-and-secrets/\" source \"/secrets.yml\") (clojure.string/ends-with? source \"-client\") (str \"tool_resources/set-values-and-secrets/add-client/\" (clojure.string/replace source #\"-client$\" \"\") \"/secrets.yml\") :else (str \"tool_resources/set-values-and-secrets/add-and-run-service/\" source \"/secrets.yml\")))"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path

              source = "{pt.input source}"

              # Read source values and secrets from mounted files
              with open("/source-values.yml") as f:
                  new_values = yaml.safe_load(f) or {}

              with open("/source-secrets.yml") as f:
                  new_secrets = yaml.safe_load(f) or {}

              # Ensure config directory exists
              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Merge new values (new values take precedence)
              for k, v in new_values.items():
                  existing_values[k] = v

              for k, v in new_secrets.items():
                  existing_secrets[k] = v

              # Write values.yml with header
              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, 'w') as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f"‚úÖ Written {len(new_values)} values to config/values.yml")
              print(f"‚úÖ Written {len(new_secrets)} secrets to config/secrets.yml")

      # Step 2: Read from user's config files (written by step 1) and set in Polytope runtime
      - id: set-from-config-files
        after: {step: write-to-config-files}
        code: |-
          pt.js
          // Read from user's config files that were written by step 1
          const values = pt.readYaml(pt.readRepoFile("config/values.yml")) || {};
          const secrets = pt.readYaml(pt.readRepoFile("config/secrets.yml")) || {};

          pt.log(`üì¶ Setting ${Object.keys(values).length} values and ${Object.keys(secrets).length} secrets from config files`);

          for (const [k, v] of Object.entries(values)) {
            pt.log(`  Setting value: ${k} = ${v}`);
            pt.setProjectValue(k, String(v));
          }

          for (const [k, v] of Object.entries(secrets)) {
            pt.log(`  Setting secret: ${k} = ***`);
            pt.setSecret(k, String(v));
          }

          pt.log("‚úÖ Successfully set all bindings");

  setup-service-for-client:
    info: |
      Sets up a service with environment variables from a client or another service.
      Adds environment variables to a service's polytope.yml.
      Environment variables reference the values/secrets set by set-values-and-secrets.
      Call set-values-and-secrets first.
    inputs:
      client-type:
        info: Client type
        type: [enum, python-fast-api, couchbase, postgres, temporal, twilio]
      consumer:
        info: Service to configure (where env vars go)
        type: str
      upstream:
        info: Service the client connects to (derives config keys)
        type: str
    run:
      - id: inject-env-vars
        code: |-
          pt.js
          // pt.param() camelCases values, convert back to kebab-case for file paths
          const clientType = pt.param("client-type").replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const consumer = pt.param("consumer");
          const upstream = pt.param("upstream");

          const script = `
          import yaml
          import re
          from pathlib import Path

          consumer = "${consumer}"
          upstream = "${upstream}"
          target = upstream.upper().replace("-", "_")

          # Read env vars template from mounted file
          with open("/env-vars.yml") as f:
              config = yaml.safe_load(f) or {}
          raw_env_vars = config.get('env_vars', [])

          # Replace {upstream} and {TARGET} in all string fields
          env_vars = []
          for var in raw_env_vars:
              resolved = {}
              for field, val in var.items():
                  if isinstance(val, str):
                      val = val.replace("{upstream}", upstream).replace("{TARGET}", target)
                  resolved[field] = val
              env_vars.append(resolved)

          # Read consumer service's polytope.yml
          service_polytope_path = Path(f"/repo/services/{consumer}/polytope.yml")
          if not service_polytope_path.exists():
              print(f"Error: Target service polytope.yml not found: services/{consumer}/polytope.yml")
              exit(1)

          with open(service_polytope_path) as f:
              content = f.read()

          # Check which env vars already exist
          vars_to_add = []
          for var in env_vars:
              if var['name'] in content:
                  print(f"  {var['name']} already exists in {consumer}, skipping")
              else:
                  vars_to_add.append(var)

          if not vars_to_add:
              print(f"All env vars already exist in services/{consumer}/polytope.yml")
              exit(0)

          # Build env var entries
          env_entries = []
          for var in vars_to_add:
              name = var['name']
              if 'value' in var:
                  env_entries.append(f'            - {{ name: {name}, value: "{var["value"]}" }}')
              else:
                  key = var['key']
                  is_secret = var.get('secret', False)
                  if is_secret:
                      env_entries.append(f'            - {{ name: {name}, value: pt.secret {key} }}')
                  else:
                      env_entries.append(f'            - {{ name: {name}, value: pt.value {key} }}')

          env_block = '\\n'.join(env_entries)

          # Find the env: section and insert after the last env var
          env_pattern = r'(env:\\s*\\n(?:\\s+-[^\\n]*\\n)*)'
          match = re.search(env_pattern, content)
          if match:
              env_section = match.group(1)
              new_env_section = env_section.rstrip('\\n') + '\\n' + env_block + '\\n'
              new_content = content[:match.start()] + new_env_section + content[match.end():]
          else:
              print(f"Warning: No 'env:' section found in services/{consumer}/polytope.yml.")
              print(f"Please manually add the following environment variables:")
              print(env_block)
              exit(0)

          with open(service_polytope_path, 'w') as f:
              f.write(new_content)

          print(f"Added {len(vars_to_add)} env vars to services/{consumer}/polytope.yml")
          for var in vars_to_add:
              print(f"   - {var['name']}")
          `;

          pt.callModule("pt/run-script", {
            repo: { type: "host", path: "." },
            language: "python",
            dependencies: ["pyyaml"],
            mounts: [{
              path: "/env-vars.yml",
              source: {
                type: "repo",
                repo: pt.moduleRepoRef,
                path: `/tool_resources/setup-service-for-client/${clientType}/env-vars.yml`
              }
            }],
            script: { type: "string", data: script }
          });

      - id: reapply-consumer
        after: {step: inject-env-vars}
        code: |-
          pt.js
          pt.log("Reapplying stack to pick up updated env vars...");
          pt.callModule("stack", {});

  add-entity:
    info: |
      Scaffolds entity models for data store clients.
      Creates entity files in models/python/models/entities/ with proper structure.
    inputs:
      client:
        info: Data store client type
        type: [enum, couchbase]
      language:
        info: Language for the entity
        type: [enum, python]
      entity-singular:
        info: Entity name in singular form (e.g., "project")
        type: str
      entity-plural:
        info: Entity name in plural form (e.g., "projects")
        type: str
    run:
      # Inlined setup-project-structure logic (chained tool resolution broken in Polytope)
      - id: scaffold-base-structure
        code: |-
          pt.js
          pt.callModule("polytope/scaffold", {
            "container-id": "scaffold-base-structure",
            actions: ["clients", "models", "services", "config"].map(dir => ({
              template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/setup-project-structure/base/${dir}` },
              path: dir,
              "on-conflict": "skip"
            }))
          });

      - id: scaffold-language
        after: {step: scaffold-base-structure}
        code: |-
          pt.js
          const lang = pt.param("language");
          pt.callModule("polytope/scaffold", {
            "container-id": "scaffold-language",
            actions: [
              {
                template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/setup-project-structure/languages/clients/${lang}` },
                path: `clients/${lang}`,
                "on-conflict": "skip"
              },
              {
                template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/setup-project-structure/languages/models/${lang}` },
                path: `models/${lang}`,
                "on-conflict": "skip"
              }
            ]
          });

      - id: scaffold-entity
        after: {step: scaffold-language}
        code: |-
          pt.js
          const client = pt.param("client");
          const lang = pt.param("language");
          const entitySingular = pt.param("entity-singular");
          const entityPlural = pt.param("entity-plural");

          const script = `
          from pathlib import Path

          client = "${client}"
          language = "${lang}"
          entity_singular = "${entitySingular}"
          entity_plural = "${entityPlural}"

          # Read the template file
          template_path = Path(f"/template/entity.py")

          if not template_path.exists():
              print(f"Template not found: {template_path}")
              exit(1)

          template_content = template_path.read_text()

          # Replace template variables
          content = template_content.replace("{{ entity_singular | capitalize }}", entity_singular.capitalize())
          content = content.replace("{{ entity_singular }}", entity_singular)
          content = content.replace("{{ entity_plural }}", entity_plural)

          # Determine output path - entities go in models/python/models/entities/
          base_path = "models/python/models/entities"
          output_path = Path(f"/repo/{base_path}/{entity_plural}.py")

          # Ensure directory exists
          output_path.parent.mkdir(parents=True, exist_ok=True)

          # Write the file
          output_path.write_text(content)

          print(f"Created entity file: {base_path}/{entity_plural}.py")
          `;

          pt.callModule("pt/run-script", {
            repo: { type: "host", path: "." },
            language: "python",
            script: { type: "string", data: script },
            mounts: [{
              path: "/template",
              source: {
                type: "repo",
                repo: pt.moduleRepoRef,
                path: `/tool_resources/add-entity/${client}/${lang}`
              }
            }]
          });

  # Internal tools for dependency handling (called by read-dependencies)
  _scaffold-deps:
    inputs:
      deps:
        type: any
      on-conflict:
        type: str
      target:
        type: str
    run:
      - tool: polytope/scaffold
        args:
          container-id: "pt.clj (str \"scaffold-deps-\" (hash (:deps inputs)))"
          actions: |-
            pt.js
            const deps = inputs.deps;
            const onConflict = inputs["on-conflict"];
            const target = inputs.target;
            deps.map(dep => ({
              template: {type: "repo", repo: pt.moduleRepoRef, path: "tool_resources/add-and-run-service/" + dep.path + "/template"},
              path: "services/" + dep.name,
              "on-conflict": onConflict,
              "add-to-tools": [{tool: target, call: dep.name}]
            }));

  _scaffold-language:
    inputs:
      language:
        type: str
    run:
      - tool: polytope/scaffold
        args:
          container-id: pt.js `scaffold-lang-${inputs.language}`
          actions:
            - template:
                type: repo
                repo: pt.js pt.moduleRepoRef
                path: pt.js `/tool_resources/setup-project-structure/languages/clients/${inputs.language}`
              path: pt.js `clients/${inputs.language}`
              on-conflict: skip
            - template:
                type: repo
                repo: pt.js pt.moduleRepoRef
                path: pt.js `/tool_resources/setup-project-structure/languages/models/${inputs.language}`
              path: pt.js `models/${inputs.language}`
              on-conflict: skip

  # Inlined set-values-and-secrets logic for dependencies (chained tool resolution broken in Polytope)
  _set-values-for-deps:
    inputs:
      deps:
        type: any
    run:
      - id: write-deps-values-to-config
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts: |-
            pt.clj
            (let [deps (:deps inputs)]
              (mapcat (fn [{n :name}]
                        [{:path (str "/source-values-" n ".yml")
                          :source {:type "repo"
                                   :repo pt/module-repo-ref
                                   :path (str "tool_resources/set-values-and-secrets/add-and-run-service/" n "/values.yml")}}
                         {:path (str "/source-secrets-" n ".yml")
                          :source {:type "repo"
                                   :repo pt/module-repo-ref
                                   :path (str "tool_resources/set-values-and-secrets/add-and-run-service/" n "/secrets.yml")}}])
                      deps))
          script:
            type: string
            data: |-
              pt.clj
              (let [deps (:deps inputs)
                    dep-names (clojure.string/join "," (map :name deps))]
                (str "import yaml
              from pathlib import Path

              dep_names = \"" dep-names "\".split(',') if \"" dep-names "\" else []

              # Ensure config directory exists
              config_dir = Path('/repo/config')
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / 'values.yml'
              secrets_file = config_dir / 'secrets.yml'

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Process each dependency
              for dep_name in dep_names:
                  values_path = f'/source-values-{dep_name}.yml'
                  secrets_path = f'/source-secrets-{dep_name}.yml'

                  try:
                      with open(values_path) as f:
                          new_values = yaml.safe_load(f) or {}
                      for k, v in new_values.items():
                          existing_values[k] = v
                      print(f'‚úÖ Merged {len(new_values)} values for {dep_name}')
                  except Exception as e:
                      print(f'‚ö†Ô∏è Could not read values for {dep_name}: {e}')

                  try:
                      with open(secrets_path) as f:
                          new_secrets = yaml.safe_load(f) or {}
                      for k, v in new_secrets.items():
                          existing_secrets[k] = v
                      print(f'‚úÖ Merged {len(new_secrets)} secrets for {dep_name}')
                  except Exception as e:
                      print(f'‚ö†Ô∏è Could not read secrets for {dep_name}: {e}')

              # Write values.yml with header
              values_header = '''# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              '''
              with open(values_file, 'w') as f:
                  f.write(values_header.replace('              ', ''))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = '''# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              '''
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace('              ', ''))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f'‚úÖ Written all dependency values to config/values.yml')
              print(f'‚úÖ Written all dependency secrets to config/secrets.yml')
              "))

      # Read from user's config files (written by previous step) and set in Polytope runtime
      - id: set-deps-values-in-runtime
        after: {step: write-deps-values-to-config}
        code: |-
          pt.js
          // Read from user's config files that were written by the previous step
          const values = pt.readYaml(pt.readRepoFile("config/values.yml")) || {};
          const secrets = pt.readYaml(pt.readRepoFile("config/secrets.yml")) || {};

          pt.log(`üì¶ Setting ${Object.keys(values).length} values and ${Object.keys(secrets).length} secrets from config files`);

          for (const [k, v] of Object.entries(values)) {
            pt.log(`  Setting value: ${k} = ${v}`);
            pt.setProjectValue(k, String(v));
          }

          for (const [k, v] of Object.entries(secrets)) {
            pt.log(`  Setting secret: ${k} = ***`);
            pt.setSecret(k, String(v));
          }

          pt.log("‚úÖ Successfully set all dependency bindings");
