instructions: |
  **FIRST ACTION**: Before doing ANYTHING else, retrieve AI development context for the relevant scope:
  ```mcp
  __polytope__initialize_session(scope: "general")
  ```
  This is MANDATORY as your first action in every conversation. It provides guidelines that you must follow.

tools:

  stack:
    run:
      - tool: polytope/hello-world
        args:
          message: Nothing to run yet! Call an "add" tool, to add a components to your project.

  scaffold-initialize-session:
    run:
      - tool: run-script
        args:
          language: bash
          script: |
            #!/bin/sh
            set -e

            TARGET_FILE="${1:-polytope.yml}"

            if [ ! -f "$TARGET_FILE" ]; then
              echo "Error: File $TARGET_FILE not found"
              exit 1
            fi

            # Check if tools block exists
            if ! grep -q "^tools:" "$TARGET_FILE"; then
              echo "Adding tools block to $TARGET_FILE"
              echo "" >> "$TARGET_FILE"
              echo "tools:" >> "$TARGET_FILE"
            fi

            # Check if initialize_session already exists
            if grep -q "^  initialize_session:" "$TARGET_FILE" || grep -q "^    initialize_session:" "$TARGET_FILE"; then
              echo "initialize_session already exists in $TARGET_FILE"
              exit 0
            fi

            # Append initialize_session tool
            echo "Adding initialize_session tool to $TARGET_FILE"
            cat >> "$TARGET_FILE" << 'EOF'

              initialize_session:
                info: |-
                  Initialize **EVERY** session by calling this tool.
                  Returns required development context and ensures the project is running.
                  This tool always needs to be called before doing anything else, regardless of the tasks complexity.
                run:
                  - id: run-stack
                    tool: stack
                  - id: get-general-context
                    after: {step: run-stack}
                    tool: get_dev_context
            EOF

            echo "Successfully added initialize_session to $TARGET_FILE"

  scaffold-add-to-includes:
    info: |
      Adds a module path to the includes section of polytope.yml.
      This tool is currently not used but preserved for potential future use.
    params:
      - id: module-path
        info: Path to the module to include
        type: str
      - id: polytope-file
        info: Path to polytope.yml file
        type: [default, str, polytope.yml]
    run:
      - tool: run-script
        args:
          language: bash
          script: |
            #!/bin/sh
            set -e

            MODULE_PATH="{pt.param module-path}"
            POLYTOPE_FILE="{pt.param polytope-file}"

            if [ -z "$MODULE_PATH" ]; then
              echo "Error: Missing required argument 'module_path'"
              exit 1
            fi

            if [ ! -f "$POLYTOPE_FILE" ]; then
              echo "Error: File $POLYTOPE_FILE not found"
              exit 1
            fi

            # Check if include block exists
            if ! grep -q "^include:" "$POLYTOPE_FILE"; then
              echo "Adding include block to $POLYTOPE_FILE"
              sed -i '1i include:' "$POLYTOPE_FILE"
            fi

            # Check if module is already included
            if grep -q "^  - ${MODULE_PATH}$" "$POLYTOPE_FILE"; then
              echo "Module '${MODULE_PATH}' is already in includes"
              exit 0
            fi

            # Add the module to includes
            echo "Adding '${MODULE_PATH}' to includes in $POLYTOPE_FILE"
            awk -v path="$MODULE_PATH" '
            /^include:/ { print; print "  - " path; next }
            { print }
            ' "$POLYTOPE_FILE" > "${POLYTOPE_FILE}.tmp" && mv "${POLYTOPE_FILE}.tmp" "$POLYTOPE_FILE"

            echo "Successfully added '${MODULE_PATH}' to includes"

  scaffold-add-dependencies:
    info: |
      Adds packages to a service's dependency file using the appropriate package manager.
      This tool is currently not used but preserved for potential future use.
      The add-dependencies tool provides a more integrated approach for adding dependencies.
    params:
      - id: target
        info: The service to add dependencies to (e.g., api, frontend)
        type: str
      - id: packages
        info: Packages to add (space separated)
        type: str
    run:
      - tool: run-script
        args:
          language: bash
          script: |
            #!/bin/sh
            set -e

            TARGET="{pt.param target}"
            PACKAGES="{pt.param packages}"

            if [ -z "$TARGET" ] || [ -z "$PACKAGES" ]; then
              echo "Error: Missing required arguments"
              echo "Usage: add-dependencies.sh <target> <packages>"
              exit 1
            fi

            echo "Adding packages to ${TARGET}: ${PACKAGES}"

            cd /target/modules/${TARGET}

            # Run the appropriate package manager based on target
            case "$TARGET" in
              api)
                echo "Installing uv..."
                apk add --no-cache curl python3
                curl -LsSf https://astral.sh/uv/install.sh | sh
                export PATH="/root/.local/bin:$PATH"
                echo "Running: uv add ${PACKAGES}"
                uv add ${PACKAGES}
                ;;
              frontend)
                echo "Installing bun..."
                apk add --no-cache curl unzip
                curl -fsSL https://bun.sh/install | sh
                export PATH="/root/.bun/bin:$PATH"
                echo "Running: bun add ${PACKAGES}"
                bun add ${PACKAGES}
                ;;
              *)
                echo "Error: Unknown target '${TARGET}'"
                echo "Supported targets: api, frontend"
                exit 1
                ;;
            esac

            echo "Successfully added packages to ${TARGET}"

  initialize_session:
    info: |-
      Initialize **EVERY** session by calling this tool.
      Returns required development context and ensures the project is running.
      This tool always needs to be called before doing anything else, regardless of the tasks complexity.
    await: [scaffold-local-overwrite]
    run:
      - id: scaffold-local-overwrite
        tool: scaffold-initialize-session
      - id: attempt-run-local-stack
        after:
          - step: scaffold-local-overwrite
        code: |-
          #pt-clj
          (pt/call-module "stack" {})
      - id: echo-context
        tool: get_dev_context

  get_dev_context:
    info: |
      Outputs essential AI development guidelines for this project.
      Call this tool before making changes to a service.
    await: [initialize-session]
    params:
      - id: scope
        info: "The scope to fetch (default: general)"
        type: [default, [enum, general, api, frontend], general]
    run:
      - id: get_dev_context
        tool: polytope/container
        args:
          image: alpine:3.21.2
          cmd: cat /scopes/{pt.param scope}.md
          mounts:
            - { path: /scopes, source: { type: repo, path: scopes } }

  add-dependencies:
    info: |
      Adds packages to a service's dependency file.
      Automatically detects the package manager for the target service.
    params:
      - id: target
        info: The service to add dependencies to (e.g., api, frontend)
        type: str
      - id: packages
        info: Packages to add (comma or space separated)
        type: str
    run:
      - id: run-add-deps
        code: |
          #pt-clj
          (let [target (:target params)
                packages (clojure.string/replace (:packages params) #"[\s,]+" " ")
                [cmd restart-policy] (case target
                                       "api" [(str "./bin/add-dependencies " packages) "never"]
                                       "frontend" [(str "bun add " packages) "on-failure"]
                                       (throw (Exception. (str "Unknown target: " target))))]
            (pt/call-module target {:id (str target "-add-deps")
                                   :cmd cmd
                                   :restart-policy restart-policy
                                   :create "always"}))

  scaffold:
    info: |
      Scaffolds a template to a specified path and adds it to project includes.
      Also scaffolds basic bluetext project structure if not already present, e.g. `lib/` folder.
      Use this for creating services, libraries, or any other template-based code.

      E.g. for an API:
        1. call `scaffold(template: "api", path: "services/my-api")`
        2. call `add-to-run-graph(target: "stack", tool: "my-api")`

    params:
      - id: template
        info: Template to scaffold into users directory.
        type: [enum, api, frontend, couchbase, temporal, postgres]
      - id: path
        info: Where to scaffold. For services use "services/<service-name>".
        type: [default, str, "services/api"]
      - id: on-conflict
        info: What to do if files already exist
        type: [default, [enum, skip, overwrite], skip]
    run:
      - id: scaffold-template
        tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"add-and-run-service/\" (:template params) \"/template\")"}
              path: pt.param path
              on-conflict: pt.param on-conflict
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: lib/py/readme}
              path: lib/py/readme
              on-conflict: skip
              auto-include: false

  add-and-run-service:
    info: |
      Scaffolds a service, adds it to includes, adds it to a run graph, and optionally runs it.
      This is a convenience tool that combines scaffold and add-to-run-graph.

      Example: add-and-run-service(template: "api", name: "my-api", run: true)
      This scaffolds to "services/my-api", adds it to stack, and runs it.
    params:
      - id: template
        info: Template to scaffold
        type: [enum, api, frontend, couchbase, temporal, postgres]
      - id: name
        info: Service name (e.g., "my-api"). Will be scaffolded to "services/<name>"
        type: str
      - id: target
        info: Which graph/tool to add to
        type: [default, str, stack]
      - id: run
        info: Whether to run the service after adding
        type: [default, bool, true]
      - id: on-conflict
        info: What to do if files already exist
        type: [default, [enum, skip, overwrite], skip]
    run:
      - id: scaffold-services
        tool: polytope/scaffold
        args:
          container-id: scaffold-services
          actions: |-
            #pt-js
            // Define dependency map: template -> list of dependent services
            const dependencies = {
              "couchbase": [{path: "config-manager", name: "config-manager"}]
            };

            const template = params.template;
            // Normalize name to lowercase and replace invalid characters
            const name = params.name.toLowerCase().replace(/[^a-z0-9_-]/g, '-');
            const onConflict = params["on-conflict"];
            const target = params.target;

            // Get dependencies for this template
            const deps = dependencies[template] || [];

            // Build and return scaffold actions
            [
              // Main service
              {
                template: {type: "repo", repo: "#pt-clj pt/module-repo-ref", path: "add-and-run-service/" + template + "/template"},
                path: "services/" + name,
                "on-conflict": onConflict,
                "add-to-tools": [{tool: target, call: name}]
              },
              // Dependencies
              ...deps.map(dep => ({
                template: {type: "repo", repo: "#pt-clj pt/module-repo-ref", path: "add-and-run-service/" + dep.path + "/template"},
                path: "services/" + dep.name,
                "on-conflict": "skip",
                "add-to-tools": [{tool: target, call: dep.name}]
              })),
            ];

      - id: run-dependencies
        after: {step: scaffold-services}
        code: |
          #pt-clj
          (when (:run params)
            (let [template (:template params)
                  dependencies {"couchbase" [{:name "config-manager"}]}
                  deps (get dependencies template [])]
              ;; Run dependencies first
              (doseq [dep deps]
                (pt/call-module (:name dep) {}))))

      - id: run-main-service
        after: {step: scaffold-services}
        code: |
          #pt-clj
          (when (:run params)
            (let [name (-> (:name params)
                           clojure.string/lower-case
                           (clojure.string/replace #"[^a-z0-9_-]" "-"))]
              ;; Run main service
              (pt/call-module name {})))

  add-to-run-graph:
    info: |
      Adds a tool to a run graph (like stack) and optionally runs it.
      Use this after scaffolding a service to make it part of your stack.

      IMPORTANT: Use the service name (NOT the full path).
      Example: After scaffolding to "services/api", use tool="api" (not "services/api")
    params:
      - id: tool
        info: Service/tool name to add (e.g., "api", "frontend", "postgres"). This is the name only, NOT the path.
        type: str
      - id: target
        info: Which graph/tool to add to
        type: [default, str, stack]
      - id: run
        info: Whether to run the tool after adding
        type: [default, bool, true]
    run:
      - id: add-to-target
        tool: run-script
        args:
          language: bash
          script: |
            #!/bin/sh
            set -e

            TARGET="{pt.param tool}"
            GRAPH="{pt.param target}"
            POLYTOPE_FILE="polytope.yml"

            if [ -z "$TARGET" ]; then
              echo "Error: Missing required argument 'target'"
              exit 1
            fi

            if [ ! -f "$POLYTOPE_FILE" ]; then
              echo "Error: File $POLYTOPE_FILE not found"
              exit 1
            fi

            # Check if tools block exists
            if ! grep -q "^tools:" "$POLYTOPE_FILE"; then
              echo "Adding tools block to $POLYTOPE_FILE"
              echo "" >> "$POLYTOPE_FILE"
              echo "tools:" >> "$POLYTOPE_FILE"
            fi

            # Check if the graph tool exists, if not create it
            if ! grep -q "^  ${GRAPH}:" "$POLYTOPE_FILE"; then
              echo "Creating '${GRAPH}' tool in $POLYTOPE_FILE"
              cat >> "$POLYTOPE_FILE" << EOF

              ${GRAPH}:
                run:
                  - tool: ${TARGET}
            EOF
              echo "Successfully created '${GRAPH}' and added '${TARGET}'"
              exit 0
            fi

            # Check if target is already in the graph
            if grep -A 20 "^  ${GRAPH}:" "$POLYTOPE_FILE" | grep -q "tool: ${TARGET}"; then
              echo "Tool '${TARGET}' is already in the '${GRAPH}' graph"
              exit 0
            fi

            # Add the target to the graph's run section
            echo "Adding '${TARGET}' to '${GRAPH}' run graph in $POLYTOPE_FILE"

            # Find the run: section under the graph and add the tool
            awk -v target="$TARGET" -v graph="$GRAPH" '
            BEGIN { in_graph=0; in_run=0; added=0 }
            /^  '"$GRAPH"':/ { in_graph=1; print; next }
            in_graph && /^    run:/ { in_run=1; print; next }
            in_graph && in_run && /^      - tool:/ && !added {
              print
              print "      - tool: " target
              added=1
              next
            }
            in_graph && /^  [a-zA-Z]/ && !/^    / { in_graph=0; in_run=0 }
            { print }
            END {
              if (in_graph && in_run && !added) {
                print "      - tool: " target
              }
            }
            ' "$POLYTOPE_FILE" > "${POLYTOPE_FILE}.tmp" && mv "${POLYTOPE_FILE}.tmp" "$POLYTOPE_FILE"

            echo "Successfully added '${TARGET}' to '${GRAPH}' graph"
      - id: run-tool
        after: {step: add-to-target}
        code: |
          #pt-clj
          (when (:run params)
            (pt/call-module (:tool params) {}))

  integrate:
    info: |
      Integrates a library into a service.
      Runs the service's integration script.
    params:
      - id: target-path
        info: Path to services integrations directory (e.g., api/src, frontend/app)
        type: str
      - id: language
        info: Language of the target service
        type: [enum, py, ts]
      - id: integration
        info: Integration/library to add (e.g., postgres-client, couchbase, twilio-client, temporal-client)
        type: str
    run:

      - id: scaffold-integration
        tool: scaffold
        args:
          template: "integrations/{pt.params language}/{pt.params integration}"
          path: "{pt.params target-path}/{pt.params integration}"
          on-conflict: skip

      - id: add-env-vars-to-polytope-yaml
        tool: run-script
        args:
          language: js
          script: |
            const targetPath="{pt.param target-path}";
            const integration="{pt.param integration}";

            const{execSync}=require('child_process'),fs=require('fs');
            execSync('npm install yaml dotenv --prefix /tmp/d',{stdio:'pipe'});
            const Y=require('/tmp/d/node_modules/yaml');
            const D=require('/tmp/d/node_modules/dotenv');

            const dotenvPath='/repo/targetPath/integration/.env';
            const ymlPath="/repo/"+targetPath/.split('/')[0]+"/polytope.yml";

            const env=D.parse(fs.readFileSync(dotenvPath,'utf8'));
            const doc=Y.parseDocument(fs.readFileSync(ymlPath,'utf8'));
            const arr=doc.get('tools').get('api').get('run').get(0).get('args').get('env');
            const exist=new Set(arr.items.filter(i=>i.get).map(i=>i.get('name')));
            Object.entries(env).filter(([k])=>!exist.has(k)).forEach(([k,v])=>arr.add({name:k,value:v}));
            fs.writeFileSync(ymlPath,doc.toString());
            console.log('Added env vars');

      - id: run-integration-script
        after: {step: scaffold-lib}
        code: |
          #pt-clj
          (let [target (:target params)
                integration (:integration params)
                script (str "./bin/add-" integration)]
            (pt/call-module target {:id (str target "-add-" integration)
                                   :cmd script
                                   :restart-policy "never"
                                   :create "always"}))

  run-script-multi-mount:
    info: |
      Runs a script in a container with support for multiple mounts.
      Use this when you need to mount multiple directories/files.
      Exactly one of script (inline string) or path-to-script must be provided.
    params:
      - id: language
        info: The scripting language to use
        type: [enum, bash, javascript, python]
      - id: script
        info: Inline script content (alternative to path-to-script)
        type: [maybe, str]
      - id: path-to-script
        info: Path to a script file in the repo (alternative to script)
        type: [maybe, str]
      - id: dependencies
        info: Dependencies to install (pip packages for Python, npm packages for JS)
        type: [maybe, [str]]
      - id: workdir
        info: Working directory in the container
        type: [default, str, /repo]
      - id: mounts
        info: "List of mounts with path and source (e.g., [{path: /container/path, source: {type: host/repo, path: ...}}])"
        type: [maybe, [any]]
    run:
      - id: run-script-container
        tool: polytope/container
        args:
          image: |-
            #pt-clj
            (case (:language params)
              "bash" "ubuntu:24.04"
              "javascript" "node:21-slim"
              "python" "python:3.12-slim")
          workdir: pt.param workdir
          mounts: |-
            #pt-clj
            (let [script-mount (if (:script params)
                                 {:path "/script"
                                  :source {:type "string"
                                          :data (:script params)}}
                                 {:path "/script"
                                  :source {:type "repo"
                                          :path (:path-to-script params)}})
                  user-mounts (or (:mounts params) [])]
              (vec (concat [script-mount] user-mounts)))
          cmd: |-
            #pt-clj
            (let [check "[ -f /script ] || { echo \"Error: The mounted script is not a file\"; exit 1; }"
                  deps (:dependencies params)]
              (case (:language params)
                "bash"
                (str "sh -c '" check "; bash /script'")
                "javascript"
                (if (seq deps)
                  (str "sh -c '" check "; npm install " (clojure.string/join " " deps) " && NODE_PATH=/node_modules node /script'")
                  (str "sh -c '" check "; node /script'"))
                "python"
                (if (seq deps)
                  (str "sh -c '" check "; pip install " (clojure.string/join " " deps) " && python /script'")
                  (str "sh -c '" check "; python /script'"))))

  run-script:
    info: |
      Runs a custom script inside a service container.
      Useful for executing one-off commands or setup scripts.
      Exactly one of  script and path-to-script must be provided.
    params:
      - id: dependencies
        info: Service to run the script in (e.g., api, frontend)
        type: [maybe, [str]]
      - id: script
        info: Script/command to run
        type: [maybe, str]
      - id: path-to-script
        info: Path to a script file to run (alternative to 'script' param)
        type: [maybe, str]
      - id: language
        info: Language of the script (e.g., bash, python)
        type: [enum, bash, python, js]
      - id: repo
        info: Repository context to run the script in
        type: [default, str, .]
      - id: mounts
        info: Additional mounts for the script container
        type: [maybe, [any]]
    run:
      - id: run-custom-script
        tool: polytope/run-script
        args:
          dependencies: pt.param dependencies
          script: |
            #pt-clj
            (cond
              (:script params)
                {:type "string", :data (:script params)}
              (:path-to-script params)
                {:type "repo", :path (:path-to-script params)
              })
          language: pt.param language
          repo: {type: host, path: pt.param repo}
          mounts: pt.param mounts

  api-add-postgres-client:
    info: |
      Adds PostgreSQL client library with database support to an API service.
      Run this after add-postgres to enable database operations in your API.
    params:
      - id: service-name
        info: Name of the API service to add the client to
        type: [default, str, api]
    run:
      - tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: lib/py/postgres-client}
              path: lib/py/postgres-client
              on-conflict: skip
      - id: run-script
        code: |
          #pt-clj
          (let [service-name (-> (:service-name params)
                                 (clojure.string/replace #"[^A-Za-z0-9-]*$" "")
                                 (clojure.string/replace #".*/" ""))
                tool-name (str service-name "-add-postgres-client")]
            (pt/call-tool tool-name {}))

  api-add-twilio-client:
    info: |
      Adds Twilio SMS client library to an API service.
      Enables SMS sending capabilities via Twilio's API.
    params:
      - id: service-name
        info: Name of the API service to add the client to
        type: [default, str, api]
    run:
      - tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: lib/py/twilio-client}
              path: lib/py/twilio-client
              on-conflict: skip
      - id: run-script
        code: |
          #pt-clj
          (let [service-name (-> (:service-name params)
                                 (clojure.string/replace #"[^A-Za-z0-9-]*$" "")
                                 (clojure.string/replace #".*/" ""))
                tool-name (str service-name "-add-twilio-client")]
            (pt/call-tool tool-name {}))

  setup-project-structure:
    info: |
      Sets up the base directory structure for a Bluetext project.
      Projects are organised by models, services, and clients.
    params:
      - id: language
        info: Language to scaffold (python).
        type: [enum, python]
      - id: skip-language
        info: Skip scaffolding language-specific structure even if language is provided
        type: [default, bool, false]
    run:
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: project-structure/base/config}
              path: config
              on-conflict: skip
      - id: scaffold-language
        after: {step: scaffold-base-structure}
        code: |
          #pt-clj
          (when (and (:language params) (not (:skip-language params)))
            (pt/call-module "add-project-language" {:language (:language params)}))

  add-project-language:
    info: |
      Adds language-specific client and model libraries to the project.
      Run setup-project-structure first if you haven't already.

      This creates language-specific library structures in:
      - clients/<language>/
      - models/<language>/
    params:
      - id: language
        info: Language to add (currently only supports python)
        type: [enum, python]
    run:
      - tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"project-structure/languages/clients/\" (:language params))"}
              path: "#pt-clj (str \"clients/\" (:language params))"
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"project-structure/languages/models/\" (:language params))"}
              path: "#pt-clj (str \"models/\" (:language params))"
              on-conflict: skip

  add-client:
    info: |
      Adds a client to the project's clients directory.
      Scaffolds the client code and updates pyproject.toml with dependencies.

      Example: add-client(name: "couchbase", language: "python")
    params:
      - id: name
        info: Client name (e.g., "couchbase", "temporal")
        type: str
      - id: language
        info: Language for the client
        type: [default, [enum, python], python]
    run:
      - id: scaffold-client
        tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"add-client/\" (:language params) \"/\" (:name params) \"/template\")"}
              path: "#pt-clj (str \"clients/\" (:language params) \"/\" (:name params))"
              on-conflict: skip
      - id: update-pyproject
        after: {step: scaffold-client}
        tool: run-script
        args:
          language: python
          script: |
            import re
            from pathlib import Path

            name = "{pt.param name}"
            language = "{pt.param language}"

            # Define dependency mapping
            dependencies_map = {
                "couchbase": "couchbase>=4.4.0",
                "temporal": "temporalio>=1.6.0",
            }

            # Get the dependency to add
            dependency = dependencies_map.get(name)
            if not dependency:
                print(f"No dependency mapping found for {name}")
                exit(0)

            # Path to pyproject.toml (scaffolded by the template)
            pyproject_path = Path(f"/repo/clients/{language}/pyproject.toml")

            # The pyproject.toml should have been scaffolded from the template
            if not pyproject_path.exists():
                print(f"‚úÖ pyproject.toml was scaffolded with the client template")
                exit(0)

            # Read the file
            content = pyproject_path.read_text()

            # Check if dependency already exists
            if dependency.split(">=")[0] in content:
                print(f"‚úÖ Dependency {dependency} already exists in pyproject.toml")
                exit(0)

            # Add dependency to the dependencies array
            # Find the dependencies section and add the new dependency
            pattern = r'(dependencies\s*=\s*\[)(.*?)(\])'

            def add_dependency(match):
                deps_start = match.group(1)
                deps_content = match.group(2)
                deps_end = match.group(3)

                # Add the new dependency
                new_dep = f'\n    "{dependency}",'
                return deps_start + deps_content + new_dep + '\n' + deps_end

            new_content = re.sub(pattern, add_dependency, content, flags=re.DOTALL)

            # Write back
            pyproject_path.write_text(new_content)
            print(f"‚úÖ Added {dependency} to pyproject.toml")

  set-client-config-values-and-secrets:
    info: |
      Sets values and secrets for a client using pt.setValue and pt.setSecret.
      Reads from pre-existing values.yml and secrets.yml files.
      This must be called before add-client-env-vars.
    params:
      - id: client
        info: Client to configure (couchbase, temporal)
        type: [enum, couchbase, temporal]
      - id: language
        info: Language for the client
        type: [default, [enum, python], python]
    run:
      - id: read-and-set-bindings
        tool: polytope/run-script
        args:
          language: python
          dependencies: [PyYAML]
          repo: {type: host, path: .}
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path
              import subprocess
              import json

              # Read the YAML files that are mounted
              values = yaml.safe_load(Path("/values.yml").read_text()) or {}
              secrets = yaml.safe_load(Path("/secrets.yml").read_text()) or {}

              print(f"üì¶ Setting {len(values)} values and {len(secrets)} secrets")

              # Write to a JSON file that Clojure can read
              config = {"values": values, "secrets": secrets}
              Path("/repo/.polytope-config.json").write_text(json.dumps(config))

              print("‚úÖ Configuration prepared for Clojure step")
          mounts: |-
            #pt-clj
            [{:path "/values.yml"
              :source {:type "repo"
                       :path (str "set-client-config-values-and-secrets/" (:language params) "/" (:client params) "/values.yml")}}
             {:path "/secrets.yml"
              :source {:type "repo"
                       :path (str "set-client-config-values-and-secrets/" (:language params) "/" (:client params) "/secrets.yml")}}]

      - id: set-polytope-bindings
        after: {step: read-and-set-bindings}
        code: |
          #pt-js
          // Read the JSON config file created by the Python step
          const configContent = pt.readFile('.polytope-config.json');
          const config = JSON.parse(configContent);

          const values = config.values || {};
          const secrets = config.secrets || {};

          console.log(`üîß Setting ${Object.keys(values).length} values and ${Object.keys(secrets).length} secrets`);

          // Set values
          for (const [key, value] of Object.entries(values)) {
            console.log(`  Setting value: ${key} = ${value}`);
            pt.setProjectValue(key, String(value));
          }

          // Set secrets
          for (const [key, value] of Object.entries(secrets)) {
            console.log(`  Setting secret: ${key} = ***`);
            pt.setSecret(key, String(value));
          }

          console.log("‚úÖ Successfully set all bindings");

          // Clean up temp file
          pt.deleteFile('.polytope-config.json');

  add-client-env-vars:
    info: |
      Adds client environment variables to a service's polytope.yml.
      Environment variables reference the values/secrets set by set-client-config-values-and-secrets.
      Call set-client-config-values-and-secrets first.
    params:
      - id: client
        info: Client providing the env vars (couchbase, temporal)
        type: [enum, couchbase, temporal]
      - id: service
        info: Service to add env vars to (api, frontend, config-manager, etc.)
        type: str
    run:
      - id: add-env-to-polytope
        tool: run-script
        args:
          language: python
          script: |
            import yaml
            from pathlib import Path

            client = "{pt.param client}"
            service = "{pt.param service}"

            # Read client config to get env var definitions
            client_config_path = Path(f"/repo/tool_resources/add-client/python/{client}/config.yml")

            if not client_config_path.exists():
                print(f"‚ùå Client config not found: {client_config_path}")
                exit(1)

            with open(client_config_path) as f:
                client_config = yaml.safe_load(f)

            env_vars = client_config.get('env_vars', [])

            # Read service's polytope.yml
            service_polytope_path = Path(f"/repo/services/{service}/polytope.yml")

            if not service_polytope_path.exists():
                print(f"‚ùå Service polytope.yml not found: {service_polytope_path}")
                exit(1)

            with open(service_polytope_path) as f:
                content = f.read()

            # Parse YAML while preserving structure
            # We need to add env vars to the service's tool definition
            # This is a simplified version - in production, use proper YAML manipulation

            import re

            # Find the env section
            env_section_pattern = r'(env:.*?)(\n          mounts:|\n        - )'

            # Build env var entries
            env_entries = []
            for var in env_vars:
                name = var['name']
                key = var['key']
                is_secret = var['secret']

                # Reference the value/secret using pt.value or pt.secret
                if is_secret:
                    env_entries.append(f'            - {{ name: {name}, value: "#pt-clj (pt/secret \\"{key}\\")" }}')
                else:
                    env_entries.append(f'            - {{ name: {name}, value: "#pt-clj (pt/value \\"{key}\\")" }}')

            # Check if env vars already exist
            for var in env_vars:
                if var['name'] in content:
                    print(f"‚ö†Ô∏è  {var['name']} already exists in {service_polytope_path}")

            # Add env vars to the file (append to env section)
            # This is a simple append - in production, use proper YAML manipulation
            env_block = '\n'.join(env_entries)

            print(f"Add these env vars to {service_polytope_path}:")
            print(env_block)
            print(f"\n‚úÖ Generated {len(env_vars)} env var entries for {client} -> {service}")

  add-entities:
    info: |
      Scaffolds entity models for data store clients.
      Creates entity files in models/python/entities/ with proper structure.
    params:
      - id: client
        info: Data store client type
        type: [enum, couchbase]
      - id: entity-singular
        info: Entity name in singular form (e.g., "project")
        type: str
      - id: entity-plural
        info: Entity name in plural form (e.g., "projects")
        type: str
      - id: is-public
        info: Whether the entity should be scaffolded in the public folder instead of private
        type: [default, bool, false]
    run:
      - id: scaffold-entities-dir
        tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "add-entities/entities-dir-template"}
              path: "#pt-clj (if (:is-public params) \"models/python/entities\" \"models/python/private/entities\")"
              on-conflict: skip

      - id: scaffold-entity
        after: {step: scaffold-entities-dir}
        tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"add-entities/\" (:client params) \"/template\")"}
              path: "#pt-clj (if (:is-public params) \"models/python/entities\" \"models/python/private/entities\")"
              on-conflict: skip
              template-values:
                entity_singular: pt.param entity-singular
                entity_plural: pt.param entity-plural

  test-mount:
    info: Test mounting the couchbase client config.yml from the blueprints repo
    run:
      - tool: run-script-multi-mount
        args:
          language: python
          dependencies: [PyYAML]
          script: |
            import yaml
            from pathlib import Path

            print("=== Testing Multi-Mount ===\n")

            # Check what's mounted
            print("üìÇ Mounted files:")
            config_path = Path("/config.yml")

            if config_path.exists():
                print(f"  ‚úì {config_path} (file)")

                # Read the couchbase client config
                print(f"\nüìÑ Reading: {config_path}")
                with open(config_path) as f:
                    config = yaml.safe_load(f)
                print(f"‚úÖ Successfully read config.yml")
                print(f"\nConfig contents:")
                print(yaml.dump(config, default_flow_style=False))
            else:
                print(f"  ‚úó {config_path} (not found)")
          mounts:
            - path: /config.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: add-client/python/couchbase/config.yml

  test-polytope-bindings:
    info: Test if polytope bindings (pt.callTool) are accessible from within a script
    run:
      - tool: run-script
        args:
          language: js
          script: |
            console.log("=== Testing Polytope Bindings ===\n");
            console.log("üîç Testing pt.callTool('polytope/hello-world')...\n");

            // Use polytope binding to call hello-world tool
            const result = pt.callTool("polytope/hello-world", {
              message: "Testing bindings from script!"
            });

            console.log("‚úÖ Successfully called polytope/hello-world\n");
            console.log("üì¶ Result:");
            console.log(JSON.stringify(result, null, 2));
