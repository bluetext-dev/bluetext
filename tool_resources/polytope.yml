instructions: |
  **FIRST ACTION**: Before doing ANYTHING else, retrieve AI development context for the relevant scope:
  ```mcp
  __polytope__initialize_session(scope: "general")
  ```
  This is MANDATORY as your first action in every conversation. It provides guidelines that you must follow.

tools:

  stack:
    run:
      - tool: polytope/hello-world
        args:
          message: Nothing to run yet! Call an "add" tool, to add a components to your project.

  scaffold-initialize-session:
    run:
      - tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/sh
              set -e

              TARGET_FILE="${1:-polytope.yml}"

              if [ ! -f "$TARGET_FILE" ]; then
                echo "Error: File $TARGET_FILE not found"
                exit 1
              fi

              # Check if tools block exists
              if ! grep -q "^tools:" "$TARGET_FILE"; then
                echo "Adding tools block to $TARGET_FILE"
                echo "" >> "$TARGET_FILE"
                echo "tools:" >> "$TARGET_FILE"
              fi

              # Check if initialize_session already exists
              if grep -q "^  initialize_session:" "$TARGET_FILE" || grep -q "^    initialize_session:" "$TARGET_FILE"; then
                echo "initialize_session already exists in $TARGET_FILE"
                exit 0
              fi

              # Append initialize_session tool
              echo "Adding initialize_session tool to $TARGET_FILE"
              cat >> "$TARGET_FILE" << 'EOF'

                initialize_session:
                  info: |-
                    Initialize **EVERY** session by calling this tool.
                    Returns required development context and ensures the project is running.
                    This tool always needs to be called before doing anything else, regardless of the tasks complexity.
                  run:
                    - id: run-stack
                      tool: stack
                    - id: get-general-context
                      after: {step: run-stack}
                      tool: get_dev_context
              EOF

              echo "Successfully added initialize_session to $TARGET_FILE"

  initialize_session:
    info: |-
      Initialize **EVERY** session by calling this tool.
      Returns required development context and ensures the project is running.
      This tool always needs to be called before doing anything else, regardless of the tasks complexity.
    await: [scaffold-local-overwrite]
    run:
      - id: scaffold-local-overwrite
        tool: scaffold-initialize-session
      - id: attempt-run-local-stack
        after:
          - step: scaffold-local-overwrite
        code: |-
          #pt-clj
          (pt/call-module "stack" {})
      - id: echo-context
        tool: get_dev_context

  get_dev_context:
    info: |
      Outputs essential AI development guidelines for this project.
      Call this tool before making changes to a service.
    await: [initialize-session]
    params:
      - id: scope
        info: "The scope to fetch (default: general)"
        type: [default, [enum, general, api, frontend], general]
    run:
      - id: get_dev_context
        tool: polytope/container
        args:
          image: registry.k8s.io/pause:3.9
          cmd: cat /scopes/{pt.param scope}.md
          mounts:
            - { path: /scopes, source: { type: repo, path: scopes } }

  add-dependencies:
    info: |
      Adds packages to a service's dependency file.
      Automatically detects the package manager for the target service.
    params:
      - id: target
        info: The service to add dependencies to (e.g., api, frontend)
        type: str
      - id: packages
        info: Packages to add (comma or space separated)
        type: str
    run:
      - id: run-add-deps
        code: |
          #pt-clj
          (let [target (:target params)
                packages (clojure.string/replace (:packages params) #"[\s,]+" " ")
                [cmd restart-policy] (case target
                                       "api" [(str "./bin/add-dependencies " packages) "never"]
                                       "frontend" [(str "bun add " packages) "on-failure"]
                                       (throw (Exception. (str "Unknown target: " target))))]
            (pt/call-module target {:id (str target "-add-deps")
                                   :cmd cmd
                                   :restart-policy restart-policy
                                   :create "always"}))

  setup-project-structure:
    info: |
      Sets up the base directory structure for a Bluetext project.
      Projects are organised by models, services, and clients.
    params:
      - id: language
        info: Language to scaffold (python).
        type: [enum, python]
      - id: skip-language
        info: Skip scaffolding language-specific structure even if language is provided
        type: [default, bool, false]
    run:
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/config}
              path: config
              on-conflict: skip
      - id: scaffold-language
        after: {step: scaffold-base-structure}
        code: |
          #pt-clj
          (when (and (:language params) (not (:skip-language params)))
            (pt/call-module "add-project-language" {:language (:language params)}))
      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ values.yml already in .gitignore"
              fi

              echo "‚úÖ .gitignore updated successfully"

  add-and-run-service:
    info: |
      Scaffolds a service, adds it to includes, adds it to a run graph, and optionally runs it.
      This is a convenience tool that combines scaffold and add-to-run-graph.

      Example: add-and-run-service(template: "api", name: "my-api", run: true)
      This scaffolds to "services/my-api", adds it to stack, and runs it.
    params:
      - id: template
        info: Template to scaffold
        type: [enum, api, frontend, couchbase, temporal, temporal-ui, postgres]
      - id: name
        info: Service name (e.g., "my-api"). Will be scaffolded to "services/<name>"
        type: str
      - id: target
        info: Which graph/tool to add to
        type: [default, str, stack]
      - id: run
        info: Whether to run the service after adding
        type: [default, bool, true]
      - id: on-conflict
        info: What to do if files already exist
        type: [default, [enum, skip, overwrite], skip]
    run:

      - id: read-dependencies
        code: |-
          #pt-clj
          (let [template (:template params)
                deps-path (str "tool_resources/add-and-run-service/" template "/dependencies.yml")
                container-id (pt/spawn {:image "registry.k8s.io/pause:3.9"
                                        :id (str "read-deps-" template)
                                        :restart {:policy "never"}
                                        :mounts [{:path "/dependencies.yml"
                                                  :source {:type "repo"
                                                           :repo pt/module-repo-ref
                                                           :path deps-path}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            (let [content (pt/read-container-file container-id "/dependencies.yml")
                  data (pt/read-yaml content)
                  deps (or (:dependencies data) [])]
              (pt/log (str "üì¶ Found " (count deps) " dependencies for " template))
              (pt/stop {:type "container" :ref container-id})
              deps))

      - id: scaffold-services
        after: {step: read-dependencies}
        tool: polytope/scaffold
        args:
          container-id: scaffold-services
          actions: |-
            #pt-js
            const template = params.template;
            // Normalize name to lowercase and replace invalid characters
            const name = params.name.toLowerCase().replace(/[^a-z0-9_-]/g, '-');
            const onConflict = params["on-conflict"];
            const target = params.target;
            const deps = pt.output("read-dependencies");

            // Build and return scaffold actions
            [
              // Main service
              {
                template: {type: "repo", repo: "#pt-clj pt/module-repo-ref", path: "add-and-run-service/" + template + "/template"},
                path: "services/" + name,
                "on-conflict": onConflict,
                "add-to-tools": [{tool: target, call: name}]
              },
              // Dependencies
              ...deps.map(dep => ({
                template: {type: "repo", repo: "#pt-clj pt/module-repo-ref", path: "add-and-run-service/" + dep.path + "/template"},
                path: "services/" + dep.name,
                "on-conflict": onConflict,
                "add-to-tools": [{tool: target, call: dep.name}]
              })),
            ];

      - id: set-values-and-secrets-for-dependencies
        after: {step: read-dependencies}
        code: |-
          #pt-js
          if (params.run) {
            const deps = pt.output("read-dependencies");
            if (deps && deps.length > 0) {
              for (const dep of deps) {
                console.log(`Setting values and secrets for dependency: ${dep.name}`);
                pt.callModule("set-values-and-secrets", {source: dep.name});
              }
            }
          }

      - id: set-values-and-secrets-for-service
        after: {step: scaffold-services}
        code: |
          #pt-clj
          (when (:run params)
            (pt/call-module "set-values-and-secrets" {:source (:template params)}))

      - id: run-dependencies
        after:
          - step: set-values-and-secrets-for-dependencies
        code: |-
          #pt-clj
          (when (:run params)
            (doseq [{n :name} (seq (pt/output "read-dependencies"))]
              (pt/log (str ":rocket: Starting dependency: " n))
              (pt/call-module n {})))

      - id: run-main-service
        after:
          - step: set-values-and-secrets-for-service
        code: |
          #pt-clj
          (when (:run params)
            (let [name (-> (:name params)
                           clojure.string/lower-case
                           (clojure.string/replace #"[^a-z0-9_-]" "-"))]
              (pt/log (str "üöÄ Starting main service: " name))
              (pt/call-module name {})))


  add-project-language:
    info: |
      Adds language-specific client and model libraries to the project.
      Run setup-project-structure first if you haven't already.

      This creates language-specific library structures in:
      - clients/<language>/
      - models/<language>/
    params:
      - id: language
        info: Language to add (currently only supports python)
        type: [enum, python]
    run:
      - tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/clients/\" (:language params))"}
              path: "#pt-clj (str \"clients/\" (:language params))"
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/models/\" (:language params))"}
              path: "#pt-clj (str \"models/\" (:language params))"
              on-conflict: skip

  add-client:
    info: |
      Adds a client to the project's clients directory.
      Scaffolds the client code and updates pyproject.toml with dependencies.

      Example: add-client(name: "couchbase", language: "python")
    params:
      - id: name
        info: Client name (e.g., "couchbase", "temporal")
        type: str
      - id: language
        info: Language for the client
        type: [default, [enum, python], python]
    run:
      # TODO: chained tool resolution broken - call setup-project-structure manually first
      # - id: setup-project-structure
      #   code: |-
      #     #pt-clj
      #     (pt/call-module "setup-project-structure" {:language (:language params)})

      - id: scaffold-client
        tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"add-client/\" (:language params) \"/\" (:name params) \"/template\")"}
              path: "#pt-clj (str \"clients/\" (:language params) \"/\" (:name params))"
              on-conflict: skip
      - id: update-pyproject
        after: {step: scaffold-client}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          script:
            type: string
            data: |
              import re
              from pathlib import Path

              name = "{pt.param name}"
              language = "{pt.param language}"

              # Define dependency mapping
              dependencies_map = {
                  "couchbase": "couchbase>=4.4.0",
                  "temporal": "temporalio>=1.6.0",
              }

              # Get the dependency to add
              dependency = dependencies_map.get(name)
              if not dependency:
                  print(f"No dependency mapping found for {name}")
                  exit(0)

              # Path to pyproject.toml (scaffolded by the template)
              pyproject_path = Path(f"/repo/clients/{language}/pyproject.toml")

              # The pyproject.toml should have been scaffolded from the template
              if not pyproject_path.exists():
                  print(f"‚úÖ pyproject.toml was scaffolded with the client template")
                  exit(0)

              # Read the file
              content = pyproject_path.read_text()

              # Check if dependency already exists
              if dependency.split(">=")[0] in content:
                  print(f"‚úÖ Dependency {dependency} already exists in pyproject.toml")
                  exit(0)

              # Add dependency to the dependencies array
              # Find the dependencies section and add the new dependency
              pattern = r'(dependencies\s*=\s*\[)(.*?)(\])'

              def add_dependency(match):
                  deps_start = match.group(1)
                  deps_content = match.group(2)
                  deps_end = match.group(3)

                  # Add the new dependency
                  new_dep = f'\n    "{dependency}",'
                  return deps_start + deps_content + new_dep + '\n' + deps_end

              new_content = re.sub(pattern, add_dependency, content, flags=re.DOTALL)

              # Write back
              pyproject_path.write_text(new_content)
              print(f"‚úÖ Added {dependency} to pyproject.toml")

      - id: set-values-and-secrets-for-client
        after: {step: update-pyproject}
        code: |
          #pt-clj
          (let [name (:name params)]
            (pt/log (str "Setting values and secrets for client: " name))
            (pt/call-module "set-values-and-secrets" {:source name}))

  set-values-and-secrets:
    info: |
      Sets values and secrets using pt.setValue and pt.setSecret.
      Reads from pre-existing values.yml and secrets.yml files in set-values-and-secrets/clients/{source}/ or set-values-and-secrets/services/{source}/.
      This must be called before setup-service-for-client.
    params:
      - id: source
        info: Source to configure (service or client name)
        type: [enum, api, frontend, config-manager, couchbase, postgres, temporal, temporal-ui, couchbase-client, temporal-client, twilio-client]
    run:
      - id: set-values-and-secrets
        code: |-
          #pt-clj
          (let [source (:source params)
                ;; Determine if source is a service or client by checking for -client suffix
                is-client (clojure.string/ends-with? source "-client")
                ;; Strip -client suffix for clients
                source-name (if is-client (clojure.string/replace source #"-client$" "") source)
                ;; Build paths: tool_resources/set-values-and-secrets/clients/{source}/ or tool_resources/set-values-and-secrets/services/{source}/
                base-path (if is-client
                           (str "tool_resources/set-values-and-secrets/clients/" source-name)
                           (str "tool_resources/set-values-and-secrets/services/" source-name))
                values-path (str base-path "/values.yml")
                secrets-path (str base-path "/secrets.yml")
                container-id (pt/spawn {:image  "registry.k8s.io/pause:3.9"
                                        :id     (str "set-values-and-secrets-" source)
                                       :restart {:policy "never"}
                                       :mounts [{:path   "/values.yml"
                                                :source {:type "repo"
                                                        :repo pt/module-repo-ref
                                                        :path values-path}}
                                               {:path   "/secrets.yml"
                                                :source {:type "repo"
                                                        :repo pt/module-repo-ref
                                                        :path secrets-path}}]})]
            (pt/await-started {:type "deployment" :ref container-id})
            ;; Read and set values
            (let [values-content (pt/read-container-file container-id "/values.yml")
                  secrets-content (pt/read-container-file container-id "/secrets.yml")
                  values (pt/read-yaml values-content)
                  secrets (pt/read-yaml secrets-content)]
              (pt/log (str "üì¶ Setting " (count values) " values and " (count secrets) " secrets for " source))
              ;; Set values
              (doseq [[k v] values]
                (pt/log (str "  Setting value: " (name k) " = " v))
                (pt/set-project-value (name k) (str v)))
              ;; Set secrets
              (doseq [[k v] secrets]
                (pt/log (str "  Setting secret: " (name k) " = ***"))
                (pt/set-secret (name k) (str v)))
              (pt/log "‚úÖ Successfully set all bindings")
              (pt/stop {:type "container" :ref container-id})))

  setup-service-for-client:
    info: |
      Sets up a service with environment variables from a client or another service.
      Adds environment variables to a service's polytope.yml.
      Environment variables reference the values/secrets set by set-values-and-secrets.
      Call set-values-and-secrets first.
    params:
      - id: service
        info: Service to set up (api, frontend, config-manager, etc.)
        type: str
      - id: client
        info: Client or service providing the configuration (use -client suffix for clients, e.g. couchbase-client)
        type: [enum, api, frontend, config-manager, couchbase, postgres, temporal, temporal-ui, couchbase-client, temporal-client, twilio-client]
    run:
      - id: add-env-to-polytope
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /env-vars.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (let [client (:client params) base-name (clojure.string/replace client #\"-client$\" \"\") clients #{\"couchbase\" \"postgres\" \"temporal\" \"twilio\"}] (if (contains? clients base-name) (str \"tool_resources/setup-service-for-client/\" base-name \"/required-env-vars.yml\") (str \"tool_resources/setup-service-for-client/services/\" client \"/required-env-vars.yml\")))"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path

              client = "{pt.param client}"
              service = "{pt.param service}"

              # Read env vars from mounted file
              env_vars_path = Path("/env-vars.yml")

              if not env_vars_path.exists():
                  print(f"‚ùå Required env vars file not found: {env_vars_path}")
                  exit(1)

              with open(env_vars_path) as f:
                  config = yaml.safe_load(f)

              env_vars = config.get('env_vars', [])

              # Read service's polytope.yml
              service_polytope_path = Path(f"/repo/services/{service}/polytope.yml")

              if not service_polytope_path.exists():
                  print(f"‚ùå Service polytope.yml not found: {service_polytope_path}")
                  exit(1)

              with open(service_polytope_path) as f:
                  content = f.read()

              # Build env var entries
              env_entries = []
              for var in env_vars:
                  name = var['name']
                  key = var['key']
                  is_secret = var['secret']

                  # Reference the value/secret using pt.value or pt.secret
                  if is_secret:
                      env_entries.append(f'            - {{ name: {name}, value: "#pt-clj (pt/secret \\"{key}\\")" }}')
                  else:
                      env_entries.append(f'            - {{ name: {name}, value: "#pt-clj (pt/value \\"{key}\\")" }}')

              # Check if env vars already exist
              for var in env_vars:
                  if var['name'] in content:
                      print(f"‚ö†Ô∏è  {var['name']} already exists in {service_polytope_path}")

              # Add env vars to the file (append to env section)
              # This is a simple append - in production, use proper YAML manipulation
              env_block = '\n'.join(env_entries)

              print(f"Add these env vars to services/{service}/polytope.yml:")
              print(env_block)
              print(f"\n‚úÖ Generated {len(env_vars)} env var entries for {client} -> {service}")

  add-entity:
    info: |
      Scaffolds entity models for data store clients.
      Creates entity files in models/python/entities/ with proper structure.
    params:
      - id: client
        info: Data store client type
        type: [enum, couchbase]
      - id: language
        info: Language for the entity
        type: [enum, python]
      - id: entity-singular
        info: Entity name in singular form (e.g., "project")
        type: str
      - id: entity-plural
        info: Entity name in plural form (e.g., "projects")
        type: str
      - id: is-public
        info: Whether the entity should be scaffolded in the public folder instead of private
        type: [default, bool, false]
    run:
      # TODO: chained tool resolution broken - call setup-project-structure manually first
      # - id: setup-project-structure
      #   code: |-
      #     #pt-clj
      #     (pt/call-module "setup-project-structure" {:language (:language params)})

      - id: scaffold-entities-dir
        tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "add-entity/entities-dir-template"}
              path: "#pt-clj (if (:is-public params) \"models/python/entities\" \"models/python/private/entities\")"
              on-conflict: skip

      - id: scaffold-entity
        after: {step: scaffold-entities-dir}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          script:
            type: string
            data: |
              from pathlib import Path

              client = "{pt.param client}"
              language = "{pt.param language}"
              entity_singular = "{pt.param entity-singular}"
              entity_plural = "{pt.param entity-plural}"
              is_public = "{pt.param is-public}" == "true"

              # Read the template file
              template_path = Path(f"/template/entity.py")

              if not template_path.exists():
                  print(f"‚ùå Template not found: {template_path}")
                  exit(1)

              template_content = template_path.read_text()

              # Replace template variables
              content = template_content.replace("{{ entity_singular | capitalize }}", entity_singular.capitalize())
              content = content.replace("{{ entity_singular }}", entity_singular)
              content = content.replace("{{ entity_plural }}", entity_plural)

              # Determine output path
              base_path = "models/python/entities" if is_public else "models/python/private/entities"
              output_path = Path(f"/repo/{base_path}/{entity_plural}.py")

              # Ensure directory exists
              output_path.parent.mkdir(parents=True, exist_ok=True)

              # Write the file
              output_path.write_text(content)

              print(f"‚úÖ Created entity file: {base_path}/{entity_plural}.py")
          mounts:
            - path: /template
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"add-entity/\" (:client params) \"/\" (:language params))"

