instructions: |
  **FIRST ACTION**: Before doing ANYTHING else, retrieve AI development context for the relevant scope:
  ```mcp
  __polytope__initialize_session()
  ```
  This is MANDATORY as your first action in every conversation. It provides guidelines that you must follow.

include:
  - implement/polytope.yml
  - setup-environment-variables/polytope.yml
  - add-and-run-service/polytope.yml
  - add-client/polytope.yml

tools:

  stack:
    run:
      - tool: polytope/hello-world
        args:
          message: Nothing to run yet! Call an "add" tool, to add a components to your project.

  scaffold-initialize-session:
    run:
      - tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/sh
              set -e

              TARGET_FILE="${1:-polytope.yml}"

              if [ ! -f "$TARGET_FILE" ]; then
                echo "Error: File $TARGET_FILE not found"
                exit 1
              fi

              # Check if tools block exists
              if ! grep -q "^tools:" "$TARGET_FILE"; then
                echo "Adding tools block to $TARGET_FILE"
                echo "" >> "$TARGET_FILE"
                echo "tools:" >> "$TARGET_FILE"
              fi

              # Check if initialize_session already exists
              if grep -q "^  initialize_session:" "$TARGET_FILE" || grep -q "^    initialize_session:" "$TARGET_FILE"; then
                echo "initialize_session already exists in $TARGET_FILE"
                exit 0
              fi

              # Append initialize_session tool
              echo "Adding initialize_session tool to $TARGET_FILE"
              cat >> "$TARGET_FILE" << 'EOF'

                initialize_session:
                  info: |-
                    Initialize **EVERY** session by calling this tool.
                    Returns required development context and ensures the project is running.
                    This tool always needs to be called before doing anything else, regardless of the tasks complexity.
                  run:
                    - id: get-general-context
                      tool: get_dev_context
                    - id: apply-stack-and-await-finish
                      tool: "stack"
              EOF

              echo "Successfully added initialize_session to $TARGET_FILE"

  load-config:
    info: |
      Loads configuration from config/values.yml and config/secrets.yml into the Polytope context.
      Useful for initializing the session with existing configuration.
    run:
      - id: load-values-and-secrets
        code: |-
          pt.js
          try {
            const values = pt.readYaml(pt.readRepoFile("config/values.yml")) || {};
            pt.log(`üì¶ Loading ${Object.keys(values).length} values from config/values.yml`);
            for (const [k, v] of Object.entries(values)) {
              pt.log(`  Setting value: ${k} = ${v}`);
              pt.setProjectValue(k, String(v));
            }
          } catch (e) {
            pt.log("‚ÑπÔ∏è No config/values.yml found or could not be read.");
          }

          try {
            const secrets = pt.readYaml(pt.readRepoFile("config/secrets.yml")) || {};
            pt.log(`üîê Loading ${Object.keys(secrets).length} secrets from config/secrets.yml`);
            for (const [k, v] of Object.entries(secrets)) {
              pt.log(`  Setting secret: ${k} = ***`);
              pt.setSecret(k, String(v));
            }
          } catch (e) {
            pt.log("‚ÑπÔ∏è No config/secrets.yml found or could not be read.");
          }

  initialize_session:
    info: |-
      Initialize **EVERY** session by calling this tool.
      Returns required development context and ensures the project is running.
      This tool always needs to be called before doing anything else, regardless of the tasks complexity.
    await: [return-context]
    run:
      - id: scaffold-local-overwrite
        tool: scaffold-initialize-session
      - id: attempt-run-local-stack
        after:
          - step: scaffold-local-overwrite
        tool: stack
      - id: return-context
        after:
          - step: scaffold-local-overwrite
        tool: get_dev_context

  get_dev_context:
    info: |
      Outputs development guidelines for a specific scope.
      Call this tool to get detailed documentation about models, clients, api, or frontend.
      If no scope is provided, returns general development context.
    params:
      - id: scope
        info: "The scope to fetch (optional, defaults to general context)"
        type: [default, [enum, general, models, clients, api, frontend], general]
    run:
      - id: get_dev_context
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          mounts:
            - { path: /general.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: initialize-session/context.md } }
            - { path: /models.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models/README.md } }
            - { path: /clients.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients/README.md } }
            - { path: /api.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: scopes/api.md } }
            - { path: /frontend.md, source: { type: repo, repo: "#pt-clj pt/module-repo-ref", path: scopes/frontend.md } }
          script:
            type: string
            data: |
              #!/bin/bash
              SCOPE="{pt.param scope}"
              case "$SCOPE" in
                models) cat /models.md ;;
                clients) cat /clients.md ;;
                api) cat /api.md ;;
                frontend) cat /frontend.md ;;
                *) cat /general.md ;;
              esac

  # add-dependencies:
  #   info: |
  #     Adds packages to a service's dependency file.
  #     Automatically detects the package manager for the target service.
  #   params:
  #     - id: target
  #       info: The service to add dependencies to (e.g., api, frontend)
  #       type: str
  #     - id: packages
  #       info: Packages to add (comma or space separated)
  #       type: str
  #   run:
  #     - id: run-add-deps
  #       code: |
  #         #pt-clj
  #         (let [target (:target params)
  #               packages (clojure.string/replace (:packages params) #"[\s,]+" " ")
  #               [cmd restart-policy] (case target
  #                                      "api" [(str "./bin/add-dependencies " packages) "never"]
  #                                      "frontend" [(str "bun add " packages) "on-failure"]
  #                                      (throw (Exception. (str "Unknown target: " target))))]
  #           (pt/call-module target {:id (str target "-add-deps")
  #                                  :cmd cmd
  #                                  :restart-policy restart-policy
  #                                  :create "always"}))

  setup-project-structure:
    info: |
      Sets up the base directory structure for a Bluetext project.
      Projects are organised by models, services, and clients.
    params:
      - id: language
        info: Language to scaffold (python).
        type: [enum, python]
      - id: skip-language
        info: Skip scaffolding language-specific structure even if language is provided
        type: [default, bool, false]
    run:
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: tool_resources/setup-project-structure/base/config}
              path: config
              on-conflict: skip
      - id: scaffold-language
        after: {step: scaffold-base-structure}
        tool: polytope/scaffold
        args:
          container-id: scaffold-language
          actions: |-
            #pt-clj
            (if (and (:language params) (not (:skip-language params)))
              [{:template {:type "repo" :repo pt/module-repo-ref :path (str "tool_resources/setup-project-structure/languages/clients/" (:language params))}
                :path (str "clients/" (:language params))
                :on-conflict "skip"}
               {:template {:type "repo" :repo pt/module-repo-ref :path (str "tool_resources/setup-project-structure/languages/models/" (:language params))}
                :path (str "models/" (:language params))
                :on-conflict "skip"}]
              [])
      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              # Create .gitignore if it doesn't exist
              if [ ! -f "$GITIGNORE_PATH" ]; then
                echo "Creating .gitignore file"
                touch "$GITIGNORE_PATH"
              fi

              # Check if secrets.yml is already in .gitignore
              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "Adding secrets.yml to .gitignore"
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ secrets.yml already in .gitignore"
              fi

              # Check if values.yml is already in .gitignore
              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "Adding values.yml to .gitignore"
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              else
                echo "‚úÖ values.yml already in .gitignore"
              fi

              echo "‚úÖ .gitignore updated successfully"




  add-project-language:
    info: |
      Adds language-specific client and model libraries to the project.
      Run setup-project-structure first if you haven't already.

      This creates language-specific library structures in:
      - clients/<language>/
      - models/<language>/
    params:
      - id: language
        info: Language to add (currently only supports python)
        type: [enum, python]
    run:
      - tool: polytope/scaffold
        args:
          container-id: scaffold-readme
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/clients/\" (:language params))"}
              path: "#pt-clj (str \"clients/\" (:language params))"
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/models/\" (:language params))"}
              path: "#pt-clj (str \"models/\" (:language params))"
              on-conflict: skip

  # add-client has been moved to tool_resources/add-client/polytope.yml

  set-values-and-secrets:
    info: |
      Sets values and secrets using pt.setValue and pt.setSecret.
      Reads from pre-existing values.yml and secrets.yml files in set-values-and-secrets/add-client/{source}/ or set-values-and-secrets/add-and-run-service/{source}/.
      Also writes the values to the user's config/values.yml and config/secrets.yml files.
      This must be called before setup-service-for-client.
    params:
      - id: source
        info: Source to configure (service, client name, or implement path)
        type: str
    run:
      # Step 1: Write values to user's config files (merge with existing)
      - id: write-to-config-files
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /source-values.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (let [source (:source params)] (cond (clojure.string/starts-with? source \"implement/\") (str \"tool_resources/set-values-and-secrets/\" source \"/values.yml\") (clojure.string/ends-with? source \"-client\") (str \"tool_resources/set-values-and-secrets/add-client/\" (clojure.string/replace source #\"-client$\" \"\") \"/values.yml\") :else (str \"tool_resources/set-values-and-secrets/add-and-run-service/\" source \"/values.yml\")))"
            - path: /source-secrets.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (let [source (:source params)] (cond (clojure.string/starts-with? source \"implement/\") (str \"tool_resources/set-values-and-secrets/\" source \"/secrets.yml\") (clojure.string/ends-with? source \"-client\") (str \"tool_resources/set-values-and-secrets/add-client/\" (clojure.string/replace source #\"-client$\" \"\") \"/secrets.yml\") :else (str \"tool_resources/set-values-and-secrets/add-and-run-service/\" source \"/secrets.yml\")))"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path

              source = "{pt.param source}"

              # Read source values and secrets from mounted files
              with open("/source-values.yml") as f:
                  new_values = yaml.safe_load(f) or {}

              with open("/source-secrets.yml") as f:
                  new_secrets = yaml.safe_load(f) or {}

              # Ensure config directory exists
              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Merge new values (new values take precedence)
              for k, v in new_values.items():
                  existing_values[k] = v

              for k, v in new_secrets.items():
                  existing_secrets[k] = v

              # Write values.yml with header
              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, 'w') as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f"‚úÖ Written {len(new_values)} values to config/values.yml")
              print(f"‚úÖ Written {len(new_secrets)} secrets to config/secrets.yml")

      # Step 2: Read from user's config files (written by step 1) and set in Polytope runtime
      - id: set-from-config-files
        after: {step: write-to-config-files}
        code: |-
          pt.js
          // Read from user's config files that were written by step 1
          const values = pt.readYaml(pt.readRepoFile("config/values.yml")) || {};
          const secrets = pt.readYaml(pt.readRepoFile("config/secrets.yml")) || {};

          pt.log(`üì¶ Setting ${Object.keys(values).length} values and ${Object.keys(secrets).length} secrets from config files`);

          for (const [k, v] of Object.entries(values)) {
            pt.log(`  Setting value: ${k} = ${v}`);
            pt.setProjectValue(k, String(v));
          }

          for (const [k, v] of Object.entries(secrets)) {
            pt.log(`  Setting secret: ${k} = ***`);
            pt.setSecret(k, String(v));
          }

          pt.log("‚úÖ Successfully set all bindings");

  setup-service-for-client:
    info: |
      Sets up a service with environment variables from a client or another service.
      Adds environment variables to a service's polytope.yml.
      Environment variables reference the values/secrets set by set-values-and-secrets.
      Call set-values-and-secrets first.
    params:
      - id: service
        info: Service to set up (api, frontend, config-manager, etc.)
        type: str
      - id: client
        info: Client providing the configuration
        type: [enum, couchbase-client, temporal-client, twilio-client, postgres-client]
    run:
      - id: set-vars
        tool: setup-environment-variables
        args:
          caller: setup-service-for-client
          source: "#pt-clj (let [client (:client params) base-name (clojure.string/replace client #\"-client$\" \"\") clients #{\"couchbase\" \"postgres\" \"temporal\" \"twilio\"}] (if (contains? clients base-name) base-name (str \"services/\" client)))"
          target: "{pt.param service}"

  add-entity:
    info: |
      Scaffolds entity models for data store clients.
      Creates entity files in models/python/models/entities/ with proper structure.
    params:
      - id: client
        info: Data store client type
        type: [enum, couchbase]
      - id: language
        info: Language for the entity
        type: [enum, python]
      - id: entity-singular
        info: Entity name in singular form (e.g., "project")
        type: str
      - id: entity-plural
        info: Entity name in plural form (e.g., "projects")
        type: str
    run:
      # Inlined setup-project-structure logic (chained tool resolution broken in Polytope)
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-base-structure
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: setup-project-structure/base/config}
              path: config
              on-conflict: skip

      - id: scaffold-language
        after: {step: scaffold-base-structure}
        tool: polytope/scaffold
        args:
          container-id: scaffold-language
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/clients/\" (:language params))"}
              path: "#pt-clj (str \"clients/\" (:language params))"
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: "#pt-clj (str \"setup-project-structure/languages/models/\" (:language params))"}
              path: "#pt-clj (str \"models/\" (:language params))"
              on-conflict: skip

      - id: scaffold-entity
        after: {step: scaffold-language}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          script:
            type: string
            data: |
              from pathlib import Path

              client = "{pt.param client}"
              language = "{pt.param language}"
              entity_singular = "{pt.param entity-singular}"
              entity_plural = "{pt.param entity-plural}"

              # Read the template file
              template_path = Path(f"/template/entity.py")

              if not template_path.exists():
                  print(f"‚ùå Template not found: {template_path}")
                  exit(1)

              template_content = template_path.read_text()

              # Replace template variables
              content = template_content.replace("{{ entity_singular | capitalize }}", entity_singular.capitalize())
              content = content.replace("{{ entity_singular }}", entity_singular)
              content = content.replace("{{ entity_plural }}", entity_plural)

              # Determine output path - entities go in models/python/models/entities/
              base_path = "models/python/models/entities"
              output_path = Path(f"/repo/{base_path}/{entity_plural}.py")

              # Ensure directory exists
              output_path.parent.mkdir(parents=True, exist_ok=True)

              # Write the file
              output_path.write_text(content)

              print(f"‚úÖ Created entity file: {base_path}/{entity_plural}.py")
          mounts:
            - path: /template
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"add-entity/\" (:client params) \"/\" (:language params))"

  # Internal tools for dependency handling (called by read-dependencies)
  _scaffold-deps:
    params:
      - id: deps
        type: any
      - id: on-conflict
        type: str
      - id: target
        type: str
    run:
      - tool: polytope/scaffold
        args:
          container-id: "#pt-clj (str \"scaffold-deps-\" (hash (:deps params)))"
          actions: |-
            #pt-js
            const deps = params.deps;
            const onConflict = params["on-conflict"];
            const target = params.target;
            deps.map(dep => ({
              template: {type: "repo", repo: "#pt-clj pt/module-repo-ref", path: "tool_resources/add-and-run-service/" + dep.path + "/template"},
              path: "services/" + dep.name,
              "on-conflict": onConflict,
              "add-to-tools": [{tool: target, call: dep.name}]
            }));

  _scaffold-language:
    params:
      - id: language
        type: str
    run:
      - tool: polytope/scaffold
        args:
          container-id: "#pt-clj (str \"scaffold-lang-\" (:language params))"
          actions: |-
            #pt-clj
            (let [lang (:language params)]
              [{:template {:type "repo" :repo pt/module-repo-ref :path (str "setup-project-structure/languages/clients/" lang)}
                :path (str "clients/" lang)
                :on-conflict "skip"}
               {:template {:type "repo" :repo pt/module-repo-ref :path (str "setup-project-structure/languages/models/" lang)}
                :path (str "models/" lang)
                :on-conflict "skip"}])

  # Inlined set-values-and-secrets logic for dependencies (chained tool resolution broken in Polytope)
  _set-values-for-deps:
    params:
      - id: deps
        type: any
    run:
      - id: write-deps-values-to-config
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts: |-
            #pt-clj
            (let [deps (:deps params)]
              (mapcat (fn [{n :name}]
                        [{:path (str "/source-values-" n ".yml")
                          :source {:type "repo"
                                   :repo pt/module-repo-ref
                                   :path (str "tool_resources/set-values-and-secrets/add-and-run-service/" n "/values.yml")}}
                         {:path (str "/source-secrets-" n ".yml")
                          :source {:type "repo"
                                   :repo pt/module-repo-ref
                                   :path (str "tool_resources/set-values-and-secrets/add-and-run-service/" n "/secrets.yml")}}])
                      deps))
          script:
            type: string
            data: |-
              #pt-clj
              (let [deps (:deps params)
                    dep-names (clojure.string/join "," (map :name deps))]
                (str "import yaml
              from pathlib import Path

              dep_names = \"" dep-names "\".split(',') if \"" dep-names "\" else []

              # Ensure config directory exists
              config_dir = Path('/repo/config')
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / 'values.yml'
              secrets_file = config_dir / 'secrets.yml'

              # Read existing values.yml or start fresh
              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              # Read existing secrets.yml or start fresh
              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              # Process each dependency
              for dep_name in dep_names:
                  values_path = f'/source-values-{dep_name}.yml'
                  secrets_path = f'/source-secrets-{dep_name}.yml'

                  try:
                      with open(values_path) as f:
                          new_values = yaml.safe_load(f) or {}
                      for k, v in new_values.items():
                          existing_values[k] = v
                      print(f'‚úÖ Merged {len(new_values)} values for {dep_name}')
                  except Exception as e:
                      print(f'‚ö†Ô∏è Could not read values for {dep_name}: {e}')

                  try:
                      with open(secrets_path) as f:
                          new_secrets = yaml.safe_load(f) or {}
                      for k, v in new_secrets.items():
                          existing_secrets[k] = v
                      print(f'‚úÖ Merged {len(new_secrets)} secrets for {dep_name}')
                  except Exception as e:
                      print(f'‚ö†Ô∏è Could not read secrets for {dep_name}: {e}')

              # Write values.yml with header
              values_header = '''# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              '''
              with open(values_file, 'w') as f:
                  f.write(values_header.replace('              ', ''))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              # Write secrets.yml with header
              secrets_header = '''# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              '''
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace('              ', ''))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

              print(f'‚úÖ Written all dependency values to config/values.yml')
              print(f'‚úÖ Written all dependency secrets to config/secrets.yml')
              "))

      # Read from user's config files (written by previous step) and set in Polytope runtime
      - id: set-deps-values-in-runtime
        after: {step: write-deps-values-to-config}
        code: |-
          pt.js
          // Read from user's config files that were written by the previous step
          const values = pt.readYaml(pt.readRepoFile("config/values.yml")) || {};
          const secrets = pt.readYaml(pt.readRepoFile("config/secrets.yml")) || {};

          pt.log(`üì¶ Setting ${Object.keys(values).length} values and ${Object.keys(secrets).length} secrets from config files`);

          for (const [k, v] of Object.entries(values)) {
            pt.log(`  Setting value: ${k} = ${v}`);
            pt.setProjectValue(k, String(v));
          }

          for (const [k, v] of Object.entries(secrets)) {
            pt.log(`  Setting secret: ${k} = ***`);
            pt.setSecret(k, String(v));
          }

          pt.log("‚úÖ Successfully set all dependency bindings");
