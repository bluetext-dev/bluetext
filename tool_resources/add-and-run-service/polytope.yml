tools:
  add-and-run-service:
    info: |
      Scaffolds a service, adds it to includes, adds it to a run graph, and optionally runs it.
      This is a convenience tool that combines scaffold and add-to-run-graph.

      Example: add-and-run-service(template: "api", name: "my-api", run: true)
      This scaffolds to "services/my-api", adds it to stack, and runs it.
    params:
      - id: template
        info: Template to scaffold
        type: [enum, python-fast-api, react-web-app, couchbase, temporal, temporal-ui, postgres, curity, kong, service-config-manager]
      - id: name
        info: Service name (e.g., "my-api"). Will be scaffolded to "services/<name>"
        type: str
      - id: target
        info: Which graph/tool to add to
        type: [default, str, stack]
      - id: run
        info: Whether to run the service after adding
        type: [default, bool, true]
      - id: version
        info: Optional version tag for the service image (e.g. "3.4"). If provided, it overrides the default image tag.
        type: [maybe, str]
      - id: on-conflict
        info: What to do if files already exist
        type: [default, [enum, skip, overwrite], skip]
    run:

      # Inlined setup-project-structure logic
      - id: scaffold-base-structure
        tool: polytope/scaffold
        args:
          container-id: scaffold-base-structure
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: /tool_resources/setup-project-structure/base/clients}
              path: clients
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: /tool_resources/setup-project-structure/base/models}
              path: models
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: /tool_resources/setup-project-structure/base/services}
              path: services
              on-conflict: skip
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: /tool_resources/setup-project-structure/base/config}
              path: config
              on-conflict: skip

      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              if [ ! -f "$GITIGNORE_PATH" ]; then
                touch "$GITIGNORE_PATH"
              fi

              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              fi

              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              fi

      - id: ensure-load-config-in-stack
        after: {step: update-gitignore}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path
              import sys

              target_file = Path("polytope.yml")

              if not target_file.exists():
                  sys.exit(0)

              with open(target_file, 'r') as f:
                  try:
                      config = yaml.safe_load(f) or {}
                  except yaml.YAMLError as exc:
                      sys.exit(1)

              if 'tools' not in config:
                  config['tools'] = {}

              tools = config['tools']

              if 'stack' not in tools:
                  tools['stack'] = {
                      'run': [
                          {'tool': 'load-config'}
                      ]
                  }
              else:
                  stack_run = tools['stack'].get('run', [])
                  if not stack_run:
                      stack_run = []
                      tools['stack']['run'] = stack_run
                  
                  has_load_config = False
                  for step in stack_run:
                      if isinstance(step, dict) and step.get('tool') == 'load-config':
                          has_load_config = True
                          break
                  
                  if not has_load_config:
                      tools['stack']['run'].insert(0, {'tool': 'load-config'})

              with open(target_file, 'w') as f:
                  yaml.dump(config, f, default_flow_style=False, sort_keys=False)

      - id: validate-service-name
        after: {step: ensure-load-config-in-stack}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path
              import sys
              import re

              name = "{pt.param name}".lower()
              name = re.sub(r"[^a-z0-9_-]", "-", name)

              # Check if service directory already exists
              service_path = Path(f"/repo/services/{name}")
              if service_path.exists():
                  print(f"ERROR: Service '{name}' already exists at services/{name}")
                  sys.exit(1)

              # Check if service is already registered in polytope.yml
              polytope_path = Path("/repo/polytope.yml")
              if polytope_path.exists():
                  with open(polytope_path) as f:
                      config = yaml.safe_load(f) or {}

                  tools = config.get('tools', {})
                  if name in tools:
                      print(f"ERROR: Service '{name}' already registered in polytope.yml")
                      sys.exit(1)

              print(f"Service name '{name}' is available")

      - id: scaffold-language
        after: {step: validate-service-name}
        code: |-
          pt.js
          const template = params.template;
          const basePath = "tool_resources/add-and-run-service";

          // Try to read language from dependencies.yml (for backward compatibility)
          let lang = null;
          try {
            const path = `${basePath}/${template}/dependencies.yml`;
            const data = pt.readYaml(pt.readRepoFile(path, { repo: pt.module_repo_ref }));
            lang = data ? data.language : null;
          } catch (e) {
            // No dependencies.yml or language specified
          }

          if (lang) {
            pt.callModule("_scaffold-language", { language: lang });
          }

          ({ language: lang });

      - id: scaffold-services
        after: {step: scaffold-language}
        tool: polytope/scaffold
        args:
          container-id: "#pt-clj (str \"scaffold-services-\" (:template params))"
          actions: |-
            #pt-clj
            (let [template (:template params)
                  name (-> (:name params)
                           clojure.string/lower-case
                           (clojure.string/replace #"[^a-z0-9_-]" "-"))
                  on-conflict (:on-conflict params)
                  target (:target params)]
              [{:template {:type "repo" :repo pt/module-repo-ref :path (str "/tool_resources/add-and-run-service/" template "/template")}
                        :path (str "services/" name)
                        :on-conflict on-conflict
                        :add-to-tools [{:tool target :call name}] }])

      - id: apply-service-version
        after: {step: scaffold-services}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path
              import sys
              import re

              version = "{pt.param version}"
              if not version or version == "null" or version == "":
                  sys.exit(0)

              name = "{pt.param name}".lower().replace(" ", "-")
              name = re.sub(r"[^a-z0-9_-]", "-", name)
              
              service_polytope_file = Path(f"services/{name}/polytope.yml")
              
              if not service_polytope_file.exists():
                  sys.exit(0)

              with open(service_polytope_file, 'r') as f:
                  try:
                      config = yaml.safe_load(f) or {}
                  except yaml.YAMLError as exc:
                      sys.exit(1)

              updated = False
              tools = config.get('tools', {})
              for tool_name, tool_def in tools.items():
                  run_steps = tool_def.get('run', [])
                  if isinstance(run_steps, dict): 
                       run_steps = [run_steps]
                  
                  for step in run_steps:
                      if isinstance(step, dict):
                          args = step.get('args', {})
                          image = args.get('image')
                          if image and isinstance(image, str):
                              if ':' in image:
                                  base_image = image.rsplit(':', 1)[0]
                                  new_image = f"{base_image}:{version}"
                              else:
                                  new_image = f"{image}:{version}"
                              
                              if new_image != image:
                                  args['image'] = new_image
                                  updated = True

              if updated:
                  with open(service_polytope_file, 'w') as f:
                      yaml.dump(config, f, default_flow_style=False, sort_keys=False)

      - id: write-service-values-to-config
        after: {step: apply-service-version}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /source-values.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"/tool_resources/set-values-and-secrets/add-and-run-service/\" (:template params) \"/values.yml\")"
            - path: /source-secrets.yml
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: "#pt-clj (str \"/tool_resources/set-values-and-secrets/add-and-run-service/\" (:template params) \"/secrets.yml\")"
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path
              import re

              template = "{pt.param template}"
              service_name = "{pt.param name}".lower()
              service_name = re.sub(r"[^a-z0-9_-]", "-", service_name)

              with open("/source-values.yml") as f:
                  new_values = yaml.safe_load(f) or {}

              with open("/source-secrets.yml") as f:
                  new_secrets = yaml.safe_load(f) or {}

              # Transform keys: replace template prefix with service name
              def transform_key(key, template_name, svc_name):
                  if key.startswith(f"{template_name}-"):
                      return key.replace(f"{template_name}-", f"{svc_name}-", 1)
                  return f"{svc_name}-{key}"

              transformed_values = {transform_key(k, template, service_name): v for k, v in new_values.items()}
              transformed_secrets = {transform_key(k, template, service_name): v for k, v in new_secrets.items()}

              config_dir = Path("/repo/config")
              config_dir.mkdir(parents=True, exist_ok=True)

              values_file = config_dir / "values.yml"
              secrets_file = config_dir / "secrets.yml"

              if values_file.exists():
                  with open(values_file) as f:
                      existing_values = yaml.safe_load(f) or {}
              else:
                  existing_values = {}

              if secrets_file.exists():
                  with open(secrets_file) as f:
                      existing_secrets = yaml.safe_load(f) or {}
              else:
                  existing_secrets = {}

              for k, v in transformed_values.items():
                  existing_values[k] = v

              for k, v in transformed_secrets.items():
                  existing_secrets[k] = v

              values_header = """# Configuration values
              # Non-sensitive configuration that can be committed to version control
              # Generated and managed by Bluetext tools

              """
              with open(values_file, 'w') as f:
                  f.write(values_header.replace("              ", ""))
                  if existing_values:
                      yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

              secrets_header = """# Configuration secrets
              # Sensitive configuration that should NOT be committed to version control
              # Add this file to .gitignore
              # Generated and managed by Bluetext tools

              """
              with open(secrets_file, 'w') as f:
                  f.write(secrets_header.replace("              ", ""))
                  if existing_secrets:
                      yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)

      - id: set-runtime-values
        after: {step: write-service-values-to-config}
        code: |-
          pt.js
          // Read from config files and set runtime values/secrets
          const values = pt.readYaml(pt.readRepoFile("config/values.yml")) || {};
          const secrets = pt.readYaml(pt.readRepoFile("config/secrets.yml")) || {};

          pt.log(`ðŸ“¦ Setting ${Object.keys(values).length} values and ${Object.keys(secrets).length} secrets`);

          for (const [k, v] of Object.entries(values)) {
            pt.setProjectValue(k, String(v));
          }

          for (const [k, v] of Object.entries(secrets)) {
            pt.setSecret(k, String(v));
          }

      - id: copy-config-files
        after: {step: set-runtime-values}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          mounts:
            - path: /tool-resources
              source:
                type: repo
                repo: "#pt-clj pt/module-repo-ref"
                path: /tool_resources/add-and-run-service
          script:
            type: string
            data: |
              import yaml
              import shutil
              from pathlib import Path
              import re

              template = "{pt.param template}"
              service_name = "{pt.param name}".lower()
              service_name = re.sub(r"[^a-z0-9_-]", "-", service_name)

              # Create service-specific config directory
              repo_config_dir = Path(f"/repo/config/{service_name}")
              repo_config_dir.mkdir(parents=True, exist_ok=True)

              service_config_dir = Path(f"/tool-resources/{template}/config")
              if service_config_dir.exists() and service_config_dir.is_dir():
                  for item in service_config_dir.iterdir():
                      target_path = repo_config_dir / item.name
                      if item.is_file():
                          shutil.copy2(item, target_path)
                      elif item.is_dir():
                          # Flatten: copy contents directly, not the directory itself
                          for sub_item in item.iterdir():
                              sub_target = repo_config_dir / sub_item.name
                              if sub_item.is_file():
                                  shutil.copy2(sub_item, sub_target)
                              elif sub_item.is_dir():
                                  shutil.copytree(sub_item, sub_target, dirs_exist_ok=True)

      - id: run-stack
        after:
          - step: copy-config-files
        code: |
          #pt-clj
          (when (:run params)
            (let [target (:target params)]
              (pt/log (str "ðŸš€ Running execution graph: " target))
              (pt/call-module target {})))

  add-service:
    info: Scaffolds a service
    params:
      - id: template
        type: [enum, python-fast-api, react-web-app, couchbase, temporal, temporal-ui, postgres, curity, kong, service-config-manager]
      - id: name
        type: str
      - id: on-conflict
        type: [default, [enum, skip, overwrite], skip]
    run:
      - tool: add-and-run-service
        args:
          template: "{pt.param template}"
          name: "{pt.param name}"
          target: "stack"
          run: false
          on-conflict: "{pt.param on-conflict}"

  run-service:
    info: Runs a service
    params:
      - id: name
        type: str
    run:
      - tool: stack
