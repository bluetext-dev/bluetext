tools:
  add-and-run-service:
    info: |
      Scaffolds a service, adds it to includes, adds it to a run graph, and optionally runs it.
      This is a convenience tool that combines scaffold and add-to-run-graph.

      Example: add-and-run-service(template-and-variables: {postgres-server: {}}, name: "my-db", run: true)
      This scaffolds postgres-server template to "services/my-db", adds it to stack, and runs it.

      Example without name (defaults to template name):
      add-and-run-service(template-and-variables: {postgres-server: {}})
      This scaffolds postgres-server template to "services/postgres-server".

      Example with variable overrides (linking to an existing service):
      add-and-run-service(
        template-and-variables: {curity: {postgres-host: "pt.value my-db-host", postgres-username: "pt.value my-db-username"}},
        name: "auth"
      )
      This scaffolds curity but configures it to use the "my-db" postgres service instead of defaults.
    inputs:
      template-and-variables:
        info: |
          Template to scaffold with optional variable overrides for linking to existing services.
          The key is the template name, the value is an object with variable overrides.
          Variables default to pt.value/pt.secret references that can be overridden to point to differently-named services.
        type:
          - either
          - postgres-server: {}
          - pgweb:
              postgres-host: [default, str, "pt.value postgres-server-host"]
              postgres-port: [default, str, "pt.value postgres-server-port"]
              postgres-database: [default, str, "pt.value postgres-server-database"]
              postgres-username: [default, str, "pt.value postgres-server-username"]
              postgres-password: [default, str, "pt.secret postgres-server-password"]
          - psql:
              postgres-host: [default, str, "pt.value postgres-server-host"]
              postgres-port: [default, str, "pt.value postgres-server-port"]
              postgres-database: [default, str, "pt.value postgres-server-database"]
              postgres-username: [default, str, "pt.value postgres-server-username"]
              postgres-password: [default, str, "pt.secret postgres-server-password"]
          - curity:
              postgres-host: [default, str, "pt.value postgres-server-host"]
              postgres-port: [default, str, "pt.value postgres-server-port"]
              postgres-username: [default, str, "pt.value postgres-server-username"]
              postgres-password: [default, str, "pt.secret postgres-server-password"]
          - kong: {}
          - couchbase-server: {}
          - python-fast-api: {}
          - react-web-app: {}
          - temporal:
              postgres-host: [default, str, "pt.value postgres-server-host"]
              postgres-port: [default, str, "pt.value postgres-server-port"]
              postgres-user: [default, str, "pt.value postgres-server-username"]
              postgres-password: [default, str, "pt.secret postgres-server-password"]
          - temporal-ui: {}
          - resonate: {}
          - service-config-manager:
              couchbase-servers: [default, [str], ["couchbase-server"]]
              postgres-servers: [default, [str], ["postgres-server"]]
      name:
        info: Optional service name (e.g., "my-api"). Defaults to the template name if not provided.
        type: [maybe, str]
      target:
        info: Which graph/tool to add to
        type: [default, str, stack]
      run:
        info: Whether to run the service after adding
        type: [default, bool, true]
      version:
        info: Optional version tag for the service image (e.g. "3.4"). If provided, it overrides the default image tag.
        type: [maybe, str]
      on-conflict:
        info: What to do if files already exist
        type: [default, [enum, skip, overwrite], skip]
    run:

      # Inlined setup-project-structure logic
      - id: scaffold-base-structure
        code: |-
          pt.js
          pt.callModule("polytope/scaffold", {
            "container-id": "scaffold-base-structure",
            actions: ["clients", "models", "services", "config"].map(dir => ({
              template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/setup-project-structure/base/${dir}` },
              path: dir,
              "on-conflict": "skip"
            }))
          });

      - id: update-gitignore
        after: {step: scaffold-base-structure}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: bash
          script:
            type: string
            data: |
              #!/bin/bash
              set -e

              GITIGNORE_PATH="/repo/.gitignore"

              if [ ! -f "$GITIGNORE_PATH" ]; then
                touch "$GITIGNORE_PATH"
              fi

              if ! grep -q "secrets\.yml" "$GITIGNORE_PATH"; then
                echo "" >> "$GITIGNORE_PATH"
                echo "# Ignore secrets files" >> "$GITIGNORE_PATH"
                echo "**/secrets.yml" >> "$GITIGNORE_PATH"
              fi

              if ! grep -q "values\.yml" "$GITIGNORE_PATH"; then
                echo "**/values.yml" >> "$GITIGNORE_PATH"
              fi

      - id: ensure-load-config-in-stack
        after: {step: update-gitignore}
        tool: pt/run-script
        args:
          repo: {type: host, path: .}
          language: python
          dependencies: [pyyaml]
          script:
            type: string
            data: |
              import yaml
              from pathlib import Path
              import sys

              target_file = Path("polytope.yml")

              if not target_file.exists():
                  sys.exit(0)

              with open(target_file, 'r') as f:
                  try:
                      config = yaml.safe_load(f) or {}
                  except yaml.YAMLError as exc:
                      sys.exit(1)

              if 'tools' not in config:
                  config['tools'] = {}

              tools = config['tools']

              if 'stack' not in tools:
                  tools['stack'] = {
                      'run': [
                          {'tool': 'load-config'}
                      ]
                  }
              else:
                  stack_run = tools['stack'].get('run', [])
                  if not stack_run:
                      stack_run = []
                      tools['stack']['run'] = stack_run
                  
                  has_load_config = False
                  for step in stack_run:
                      if isinstance(step, dict) and step.get('tool') == 'load-config':
                          has_load_config = True
                          break
                  
                  if not has_load_config:
                      tools['stack']['run'].insert(0, {'tool': 'load-config'})

              with open(target_file, 'w') as f:
                  yaml.dump(config, f, default_flow_style=False, sort_keys=False)

      - id: validate-service-name
        after: {step: ensure-load-config-in-stack}
        code: |-
          pt.js
          const templateAndVars = pt.param("template-and-variables");
          const rawKey = Object.keys(templateAndVars)[0];
          const template = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const nameParam = pt.param("name");
          const name = (nameParam || template).toLowerCase().replace(/[^a-z0-9_-]/g, "-");

          // Check if service is already registered in polytope.yml
          try {
            const config = pt.readYaml(pt.readRepoFile("polytope.yml")) || {};
            const tools = config.tools || {};
            if (tools[name]) {
              throw new Error("Service '" + name + "' already registered in polytope.yml");
            }
          } catch (e) {
            if (e.message && e.message.includes("already registered")) throw e;
          }

          // Check if service directory already exists by trying to read its polytope.yml
          try {
            pt.readRepoFile("services/" + name + "/polytope.yml");
            throw new Error("Service '" + name + "' already exists at services/" + name);
          } catch (e) {
            if (e.message && e.message.includes("already exists")) throw e;
          }

          pt.log("Service name '" + name + "' is available");

      - id: scaffold-language
        after: {step: validate-service-name}
        code: |-
          pt.js
          // Extract template name from template-and-variables param
          // Note: pt.param() converts kebab-case keys to camelCase, so we convert back
          const templateAndVars = pt.param("template-and-variables");
          const rawKey = Object.keys(templateAndVars)[0];
          const template = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const variables = templateAndVars[rawKey] || {};
          const basePath = "tool_resources/add-and-run-service";

          // Try to read language from dependencies.yml (for backward compatibility)
          let lang = null;
          try {
            const path = `${basePath}/${template}/dependencies.yml`;
            const data = pt.readYaml(pt.readRepoFile(path, { repo: pt.moduleRepoRef }));
            lang = data ? data.language : null;
          } catch (e) {
            // No dependencies.yml or language specified
          }

          if (lang) {
            pt.callModule("polytope/scaffold", {
              "container-id": `scaffold-lang-${lang}`,
              actions: [
                {
                  template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/setup-project-structure/languages/clients/${lang}` },
                  path: `clients/${lang}`,
                  "on-conflict": "skip"
                },
                {
                  template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/setup-project-structure/languages/models/${lang}` },
                  path: `models/${lang}`,
                  "on-conflict": "skip"
                }
              ]
            });
          }

          ({ language: lang, template: template, variables: variables });

      - id: scaffold-services
        after: {step: scaffold-language}
        code: |-
          pt.js
          const templateAndVars = pt.param("template-and-variables");
          const rawKey = Object.keys(templateAndVars)[0];
          const template = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const variables = templateAndVars[rawKey] || {};
          const nameParam = pt.param("name");
          const name = (nameParam || template).toLowerCase().replace(/[^a-z0-9_-]/g, "-");
          const onConflict = pt.param("on-conflict");
          const target = pt.param("target");
          const scaffoldParams = {};
          for (const [k, v] of Object.entries(variables)) {
            scaffoldParams[k] = String(v);
          }
          pt.callModule("polytope/scaffold", {
            "container-id": `scaffold-services-${template}`,
            actions: [{
              template: { type: "repo", repo: pt.moduleRepoRef, path: `/tool_resources/add-and-run-service/${template}/template` },
              path: `services/${name}`,
              "on-conflict": onConflict,
              inputs: scaffoldParams,
              "add-to-tools": [{ tool: target, call: name }]
            }]
          });

      - id: apply-service-version
        after: {step: scaffold-services}
        code: |-
          pt.js
          const templateAndVars = pt.param("template-and-variables");
          const rawKey = Object.keys(templateAndVars)[0];
          const template = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const nameParam = pt.param("name");
          const name = (nameParam || template).toLowerCase().replace(/[^a-z0-9_-]/g, "-");
          const version = pt.param("version");

          if (!version) {
            pt.log("No version specified, skipping");
          } else {
            const script = `
          import yaml
          from pathlib import Path
          import sys

          version = "${version}"
          name = "${name}"

          service_polytope_file = Path(f"/repo/services/{name}/polytope.yml")

          if not service_polytope_file.exists():
              sys.exit(0)

          with open(service_polytope_file, 'r') as f:
              try:
                  config = yaml.safe_load(f) or {}
              except yaml.YAMLError as exc:
                  sys.exit(1)

          updated = False
          tools = config.get('tools', {})
          for tool_name, tool_def in tools.items():
              run_steps = tool_def.get('run', [])
              if isinstance(run_steps, dict):
                   run_steps = [run_steps]

              for step in run_steps:
                  if isinstance(step, dict):
                      args = step.get('args', {})
                      image = args.get('image')
                      if image and isinstance(image, str):
                          if ':' in image:
                              base_image = image.rsplit(':', 1)[0]
                              new_image = f"{base_image}:{version}"
                          else:
                              new_image = f"{image}:{version}"

                          if new_image != image:
                              args['image'] = new_image
                              updated = True

          if updated:
              with open(service_polytope_file, 'w') as f:
                  yaml.dump(config, f, default_flow_style=False, sort_keys=False)
            `;

            pt.callModule("pt/run-script", {
              repo: { type: "host", path: "." },
              language: "python",
              dependencies: ["pyyaml"],
              script: { type: "string", data: script }
            });
          }

      - id: write-service-values-to-config
        after: {step: apply-service-version}
        code: |-
          pt.js
          const templateAndVars = pt.param("template-and-variables");
          const rawKey = Object.keys(templateAndVars)[0];
          const template = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const nameParam = pt.param("name");
          const name = (nameParam || template).toLowerCase().replace(/[^a-z0-9_-]/g, "-");

          // Read source values and secrets from module repo
          let sourceValues = "";
          let sourceSecrets = "";
          try {
            sourceValues = pt.readRepoFile(
              `tool_resources/set-values-and-secrets/add-and-run-service/${template}/values.yml`,
              { repo: pt.moduleRepoRef }
            );
          } catch (e) { pt.log("No source values.yml found"); }
          try {
            sourceSecrets = pt.readRepoFile(
              `tool_resources/set-values-and-secrets/add-and-run-service/${template}/secrets.yml`,
              { repo: pt.moduleRepoRef }
            );
          } catch (e) { pt.log("No source secrets.yml found"); }

          // Escape for embedding in Python string
          const escValues = sourceValues.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
          const escSecrets = sourceSecrets.replace(/\\/g, "\\\\").replace(/'/g, "\\'");

          const script = `
          import yaml
          import re as _re
          from pathlib import Path

          template = "${template}"
          service_name = "${name}"

          new_values = yaml.safe_load('''${escValues}''') or {}
          new_secrets = yaml.safe_load('''${escSecrets}''') or {}

          def to_kebab_case(s):
              # Insert hyphen before uppercase letters (camelCase/PascalCase)
              s = _re.sub(r'([a-z0-9])([A-Z])', r'\\1-\\2', s)
              # Replace underscores and spaces with hyphens
              s = _re.sub(r'[_ ]+', '-', s)
              return s.lower()

          def transform_key(key, svc_name):
              key = to_kebab_case(key)
              return key.replace("{name}", svc_name) if "{name}" in key else key

          def transform_value(val, svc_name):
              if isinstance(val, str) and "{name}" in val:
                  return val.replace("{name}", svc_name)
              return val

          transformed_values = {transform_key(k, service_name): transform_value(v, service_name) for k, v in new_values.items()}
          transformed_secrets = {transform_key(k, service_name): transform_value(v, service_name) for k, v in new_secrets.items()}

          config_dir = Path('/repo/config')
          config_dir.mkdir(parents=True, exist_ok=True)
          values_file = config_dir / 'values.yml'
          secrets_file = config_dir / 'secrets.yml'

          existing_values = yaml.safe_load(open(values_file).read()) if values_file.exists() else {}
          existing_values = existing_values or {}
          existing_secrets = yaml.safe_load(open(secrets_file).read()) if secrets_file.exists() else {}
          existing_secrets = existing_secrets or {}

          existing_values.update(transformed_values)
          existing_secrets.update(transformed_secrets)

          with open(values_file, 'w') as f:
              f.write('# Configuration values\\n# Generated and managed by Bluetext tools\\n\\n')
              if existing_values:
                  yaml.dump(existing_values, f, default_flow_style=False, sort_keys=True)

          with open(secrets_file, 'w') as f:
              f.write('# Configuration secrets\\n# Add this file to .gitignore\\n# Generated and managed by Bluetext tools\\n\\n')
              if existing_secrets:
                  yaml.dump(existing_secrets, f, default_flow_style=False, sort_keys=True)
          `;

          pt.callModule("pt/run-script", {
            repo: { type: "host", path: "." },
            language: "python",
            dependencies: ["pyyaml"],
            script: { type: "string", data: script }
          });

      - id: set-runtime-values
        after: {step: write-service-values-to-config}
        code: |-
          pt.js
          // pt.readYaml converts kebab-case keys to camelCase, so convert back
          function toKebabCase(s) {
            return s.replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/[_ ]+/g, "-").toLowerCase();
          }

          // Read from config files and set runtime values/secrets
          const values = pt.readYaml(pt.readRepoFile("config/values.yml")) || {};
          const secrets = pt.readYaml(pt.readRepoFile("config/secrets.yml")) || {};

          pt.log(`Setting ${Object.keys(values).length} values and ${Object.keys(secrets).length} secrets`);

          for (const [k, v] of Object.entries(values)) {
            pt.setProjectValue(toKebabCase(k), String(v));
          }

          for (const [k, v] of Object.entries(secrets)) {
            pt.setSecret(toKebabCase(k), String(v));
          }

      - id: copy-config-files
        after: {step: set-runtime-values}
        code: |-
          pt.js
          const templateAndVars = pt.param("template-and-variables");
          const rawKey = Object.keys(templateAndVars)[0];
          const template = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
          const nameParam = pt.param("name");
          const name = (nameParam || template).toLowerCase().replace(/[^a-z0-9_-]/g, "-");

          const script = `
          import shutil
          from pathlib import Path

          template = "${template}"
          service_name = "${name}"

          repo_config_dir = Path(f'/repo/config/{service_name}')
          repo_config_dir.mkdir(parents=True, exist_ok=True)

          service_config_dir = Path(f'/tool-resources/{template}/config')
          if service_config_dir.exists() and service_config_dir.is_dir():
              for item in service_config_dir.iterdir():
                  target_path = repo_config_dir / item.name
                  if item.is_file():
                      shutil.copy2(item, target_path)
                  elif item.is_dir():
                      for sub_item in item.iterdir():
                          sub_target = repo_config_dir / sub_item.name
                          if sub_item.is_file():
                              shutil.copy2(sub_item, sub_target)
                          elif sub_item.is_dir():
                              shutil.copytree(sub_item, sub_target, dirs_exist_ok=True)
          `;

          pt.callModule("pt/run-script", {
            repo: { type: "host", path: "." },
            language: "python",
            mounts: [{
              path: "/tool-resources",
              source: { type: "repo", repo: pt.moduleRepoRef, path: "/tool_resources/add-and-run-service" }
            }],
            script: { type: "string", data: script }
          });

      - id: run-service
        after:
          - step: copy-config-files
        code: |-
          pt.js
          const run = pt.param("run");
          if (run) {
            const templateAndVars = pt.param("template-and-variables");
            const rawKey = Object.keys(templateAndVars)[0];
            const template = rawKey.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
            const nameParam = pt.param("name");
            const name = (nameParam || template).toLowerCase().replace(/[^a-z0-9_-]/g, "-");
            pt.log(`Running service: ${name}`);
            pt.callModule(name, {});
          }

  add-service:
    info: Scaffolds a service without running it
    inputs:
      template-and-variables:
        info: |
          Template to scaffold with optional variable overrides.
          Same as add-and-run-service but with run=false.
        type:
          - either
          - postgres-server: {}
          - pgweb:
              postgres-host: [default, str, "pt.value postgres-server-host"]
              postgres-port: [default, str, "pt.value postgres-server-port"]
              postgres-database: [default, str, "pt.value postgres-server-database"]
              postgres-username: [default, str, "pt.value postgres-server-username"]
              postgres-password: [default, str, "pt.secret postgres-server-password"]
          - psql:
              postgres-host: [default, str, "pt.value postgres-server-host"]
              postgres-port: [default, str, "pt.value postgres-server-port"]
              postgres-database: [default, str, "pt.value postgres-server-database"]
              postgres-username: [default, str, "pt.value postgres-server-username"]
              postgres-password: [default, str, "pt.secret postgres-server-password"]
          - curity:
              postgres-host: [default, str, "pt.value postgres-server-host"]
              postgres-port: [default, str, "pt.value postgres-server-port"]
              postgres-username: [default, str, "pt.value postgres-server-username"]
              postgres-password: [default, str, "pt.secret postgres-server-password"]
          - kong: {}
          - couchbase-server: {}
          - python-fast-api: {}
          - react-web-app: {}
          - temporal:
              postgres-host: [default, str, "pt.value postgres-server-host"]
              postgres-port: [default, str, "pt.value postgres-server-port"]
              postgres-user: [default, str, "pt.value postgres-server-username"]
              postgres-password: [default, str, "pt.secret postgres-server-password"]
          - temporal-ui: {}
          - resonate: {}
          - service-config-manager:
              couchbase-servers: [default, [str], ["couchbase-server"]]
              postgres-servers: [default, [str], ["postgres-server"]]
      name:
        info: Optional service name. Defaults to the template name if not provided.
        type: [maybe, str]
      on-conflict:
        type: [default, [enum, skip, overwrite], skip]
    run:
      - tool: add-and-run-service
        args:
          template-and-variables: "pt.clj (:template-and-variables inputs)"
          name: pt.param name
          target: "stack"
          run: false
          on-conflict: pt.param on-conflict

  run-service:
    info: Runs a service
    inputs:
      name:
        type: str
    run:
      - tool: stack
